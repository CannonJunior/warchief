import 'package:flutter/material.dart';
import 'package:vector_math/vector_math.dart' hide Colors;

/// Ability type enumeration
enum AbilityType {
  melee,      // Close-range physical attacks
  ranged,     // Projectile-based attacks
  heal,       // Health restoration
  buff,       // Positive effects on self/allies
  debuff,     // Negative effects on enemies
  aoe,        // Area of effect damage
  dot,        // Damage over time
  channeled,  // Requires standing still to cast
  summon,     // Creates temporary units
  utility,    // Non-combat abilities (movement, vision, etc.)
}

/// Icon for each ability type â€” matches the Abilities Codex.
extension AbilityTypeIcon on AbilityType {
  IconData get icon {
    switch (this) {
      case AbilityType.melee:
        return Icons.sports_martial_arts;
      case AbilityType.ranged:
        return Icons.gps_fixed;
      case AbilityType.heal:
        return Icons.favorite;
      case AbilityType.buff:
        return Icons.arrow_upward;
      case AbilityType.debuff:
        return Icons.arrow_downward;
      case AbilityType.aoe:
        return Icons.blur_circular;
      case AbilityType.dot:
        return Icons.local_fire_department;
      case AbilityType.channeled:
        return Icons.stream;
      case AbilityType.summon:
        return Icons.pets;
      case AbilityType.utility:
        return Icons.build;
    }
  }
}

/// Status effect type enumeration
enum StatusEffect {
  none,
  burn,       // Fire damage over time
  freeze,     // Movement slow/stop
  poison,     // Nature damage over time
  stun,       // Cannot act
  slow,       // Reduced movement speed
  bleed,      // Physical damage over time
  blind,      // Reduced accuracy/vision
  root,       // Cannot move but can act
  silence,    // Cannot use abilities
  haste,      // Increased movement/attack speed
  shield,     // Damage absorption
  regen,      // Health over time
  strength,   // Increased damage
  weakness,   // Reduced damage output
  fear,       // Causes uncontrolled fleeing
  vulnerablePhysical,   // Increased physical damage taken
  vulnerableFire,       // Increased fire damage taken
  vulnerableFrost,      // Increased frost damage taken
  vulnerableLightning,  // Increased lightning damage taken
  vulnerableNature,     // Increased nature damage taken
  vulnerableShadow,     // Increased shadow damage taken
  vulnerableArcane,     // Increased arcane damage taken
  vulnerableHoly,       // Increased holy damage taken
}

/// Maps a DamageSchool to its corresponding vulnerability StatusEffect.
StatusEffect vulnerabilityForSchool(DamageSchool school) {
  switch (school) {
    case DamageSchool.physical: return StatusEffect.vulnerablePhysical;
    case DamageSchool.fire: return StatusEffect.vulnerableFire;
    case DamageSchool.frost: return StatusEffect.vulnerableFrost;
    case DamageSchool.lightning: return StatusEffect.vulnerableLightning;
    case DamageSchool.nature: return StatusEffect.vulnerableNature;
    case DamageSchool.shadow: return StatusEffect.vulnerableShadow;
    case DamageSchool.arcane: return StatusEffect.vulnerableArcane;
    case DamageSchool.holy: return StatusEffect.vulnerableHoly;
  }
}

/// Visual effect type for channeled abilities
enum ChannelEffect {
  none,         // No visual effect
  lifeDrain,    // Purple vortex lines from target to caster
  blizzard,     // Ice crystals descending from sky in AoE area
  earthquake,   // Earth particles erupting upward from ground
  conduit,      // Lightning bolts from sky to target
}

/// Damage school types for vulnerability and damage classification
enum DamageSchool {
  physical,   // Melee/physical attacks
  fire,       // Burn spells
  frost,      // Ice/freeze spells
  lightning,  // Storm/electrical
  nature,     // Poison/bleed/root
  shadow,     // Necromancy, curses
  arcane,     // Pure magical energy
  holy,       // Divine healing/damage
}

/// Mana color types for different magical energy sources
enum ManaColor {
  none,   // No mana cost (physical abilities)
  blue,   // Arcane/magical energy - regenerated near Ley Lines
  red,    // Blood/rage energy - generated by melee damage and Ley Power nodes
  white,  // Wind/air energy - regenerated by wind exposure
  green,  // Nature/life energy - regenerated by proximity to nature
  // Future mana colors:
  // gold,   // Divine/holy energy
  // purple, // Shadow/void energy
}

/// Ability data class containing all parameters for an ability
///
/// All ability parameters (name, damage, cooldown, color, etc.) are defined
/// using this class for easy tuning and maintenance.
class AbilityData {
  final String name;
  final String description;
  final AbilityType type;
  final double damage;
  final double cooldown;
  final double duration;
  final double range;
  final Vector3 color;
  final Vector3 impactColor;
  final double impactSize;
  final double projectileSpeed;
  final double projectileSize;
  final double healAmount;

  // Mana cost
  final ManaColor manaColor;
  final double manaCost;

  // Dual-mana support (for abilities requiring two mana colors)
  final ManaColor secondaryManaColor;
  final double secondaryManaCost;

  // Extended properties for advanced abilities
  final StatusEffect statusEffect;
  final double statusDuration;
  final double statusStrength;
  final double aoeRadius;
  final int dotTicks;
  final double knockbackForce;
  final bool piercing;
  final int maxTargets;
  final double castTime;
  final String category;

  // Windup mechanics for melee abilities
  /// Windup time in seconds before melee ability activates (0 = instant)
  final double windupTime;

  /// Movement speed multiplier during windup (0.0 = stopped, 1.0 = full speed)
  /// Only applies during windupTime for melee abilities
  final double windupMovementSpeed;

  /// Hit radius for ability - larger for windup melee attacks
  /// Defaults to range if not specified
  final double? hitRadius;

  /// Whether the ability requires the caster to be stationary
  /// For ranged abilities with castTime, movement cancels the cast
  final bool requiresStationary;

  /// Visual effect displayed while channeling (only for channeled abilities)
  final ChannelEffect channelEffect;

  /// Damage school for vulnerability system classification
  final DamageSchool damageSchool;

  /// Whether this ability applies a permanent vulnerability debuff on hit
  final bool appliesPermanentVulnerability;

  const AbilityData({
    required this.name,
    required this.description,
    required this.type,
    this.damage = 0.0,
    required this.cooldown,
    this.duration = 0.0,
    this.range = 0.0,
    required this.color,
    required this.impactColor,
    this.impactSize = 0.5,
    this.projectileSpeed = 0.0,
    this.projectileSize = 0.0,
    this.healAmount = 0.0,
    // Extended property defaults
    this.statusEffect = StatusEffect.none,
    this.statusDuration = 0.0,
    this.statusStrength = 0.0,
    this.aoeRadius = 0.0,
    this.dotTicks = 0,
    this.knockbackForce = 0.0,
    this.piercing = false,
    this.maxTargets = 1,
    this.castTime = 0.0,
    this.category = 'general',
    // Windup mechanics defaults
    this.windupTime = 0.0,
    this.windupMovementSpeed = 1.0,
    this.hitRadius,
    this.requiresStationary = false,
    this.channelEffect = ChannelEffect.none,
    // Damage school defaults
    this.damageSchool = DamageSchool.physical,
    this.appliesPermanentVulnerability = false,
    // Mana cost defaults
    this.manaColor = ManaColor.none,
    this.manaCost = 0.0,
    this.secondaryManaColor = ManaColor.none,
    this.secondaryManaCost = 0.0,
  });

  /// Icon for this ability's type (matches the Abilities Codex).
  IconData get typeIcon => type.icon;

  /// Ability color as a Flutter Color.
  Color get flutterColor => Color.fromRGBO(
    (color.x * 255).round(),
    (color.y * 255).round(),
    (color.z * 255).round(),
    1.0,
  );

  /// Whether this ability requires mana
  bool get requiresMana => manaColor != ManaColor.none && manaCost > 0;

  /// Whether this ability requires blue mana specifically
  bool get requiresBlueMana => manaColor == ManaColor.blue && manaCost > 0;

  /// Whether this ability requires red mana specifically
  bool get requiresRedMana => manaColor == ManaColor.red && manaCost > 0;

  /// Whether this ability requires white mana specifically
  bool get requiresWhiteMana => manaColor == ManaColor.white && manaCost > 0;

  /// Whether this ability requires green mana (primary or secondary)
  bool get requiresGreenMana =>
      (manaColor == ManaColor.green && manaCost > 0) ||
      (secondaryManaColor == ManaColor.green && secondaryManaCost > 0);

  /// Whether this ability requires two different mana colors
  bool get requiresDualMana =>
      secondaryManaColor != ManaColor.none && secondaryManaCost > 0;

  /// Effective hit radius - uses hitRadius if set, otherwise falls back to range
  double get effectiveHitRadius => hitRadius ?? range;

  /// Whether this ability has a windup phase
  bool get hasWindup => windupTime > 0;

  /// Whether this ability has a cast time (for ranged)
  bool get hasCastTime => castTime > 0;

  /// Whether this is an instant ability (no cast or windup)
  bool get isInstant => castTime <= 0 && windupTime <= 0;

  /// Whether this ability targets self (never range-checked)
  bool get isSelfCast =>
      type == AbilityType.heal ||
      type == AbilityType.buff ||
      type == AbilityType.summon ||
      (type == AbilityType.aoe && range <= 0);

  /// Returns a copy of this AbilityData with specified fields replaced
  AbilityData copyWith({
    String? name,
    String? description,
    AbilityType? type,
    double? damage,
    double? cooldown,
    double? duration,
    double? range,
    Vector3? color,
    Vector3? impactColor,
    double? impactSize,
    double? projectileSpeed,
    double? projectileSize,
    double? healAmount,
    ManaColor? manaColor,
    double? manaCost,
    ManaColor? secondaryManaColor,
    double? secondaryManaCost,
    StatusEffect? statusEffect,
    double? statusDuration,
    double? statusStrength,
    double? aoeRadius,
    int? dotTicks,
    double? knockbackForce,
    bool? piercing,
    int? maxTargets,
    double? castTime,
    String? category,
    double? windupTime,
    double? windupMovementSpeed,
    double? hitRadius,
    bool? requiresStationary,
    ChannelEffect? channelEffect,
    DamageSchool? damageSchool,
    bool? appliesPermanentVulnerability,
  }) {
    return AbilityData(
      name: name ?? this.name,
      description: description ?? this.description,
      type: type ?? this.type,
      damage: damage ?? this.damage,
      cooldown: cooldown ?? this.cooldown,
      duration: duration ?? this.duration,
      range: range ?? this.range,
      color: color ?? this.color,
      impactColor: impactColor ?? this.impactColor,
      impactSize: impactSize ?? this.impactSize,
      projectileSpeed: projectileSpeed ?? this.projectileSpeed,
      projectileSize: projectileSize ?? this.projectileSize,
      healAmount: healAmount ?? this.healAmount,
      manaColor: manaColor ?? this.manaColor,
      manaCost: manaCost ?? this.manaCost,
      secondaryManaColor: secondaryManaColor ?? this.secondaryManaColor,
      secondaryManaCost: secondaryManaCost ?? this.secondaryManaCost,
      statusEffect: statusEffect ?? this.statusEffect,
      statusDuration: statusDuration ?? this.statusDuration,
      statusStrength: statusStrength ?? this.statusStrength,
      aoeRadius: aoeRadius ?? this.aoeRadius,
      dotTicks: dotTicks ?? this.dotTicks,
      knockbackForce: knockbackForce ?? this.knockbackForce,
      piercing: piercing ?? this.piercing,
      maxTargets: maxTargets ?? this.maxTargets,
      castTime: castTime ?? this.castTime,
      category: category ?? this.category,
      windupTime: windupTime ?? this.windupTime,
      windupMovementSpeed: windupMovementSpeed ?? this.windupMovementSpeed,
      hitRadius: hitRadius ?? this.hitRadius,
      requiresStationary: requiresStationary ?? this.requiresStationary,
      channelEffect: channelEffect ?? this.channelEffect,
      damageSchool: damageSchool ?? this.damageSchool,
      appliesPermanentVulnerability: appliesPermanentVulnerability ?? this.appliesPermanentVulnerability,
    );
  }

  /// Serializes all fields to a Map for persistence
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'description': description,
      'type': type.index,
      'damage': damage,
      'cooldown': cooldown,
      'duration': duration,
      'range': range,
      'color': [color.x, color.y, color.z],
      'impactColor': [impactColor.x, impactColor.y, impactColor.z],
      'impactSize': impactSize,
      'projectileSpeed': projectileSpeed,
      'projectileSize': projectileSize,
      'healAmount': healAmount,
      'manaColor': manaColor.index,
      'manaCost': manaCost,
      'secondaryManaColor': secondaryManaColor.index,
      'secondaryManaCost': secondaryManaCost,
      'statusEffect': statusEffect.index,
      'statusDuration': statusDuration,
      'statusStrength': statusStrength,
      'aoeRadius': aoeRadius,
      'dotTicks': dotTicks,
      'knockbackForce': knockbackForce,
      'piercing': piercing,
      'maxTargets': maxTargets,
      'castTime': castTime,
      'category': category,
      'windupTime': windupTime,
      'windupMovementSpeed': windupMovementSpeed,
      'hitRadius': hitRadius,
      'requiresStationary': requiresStationary,
      'channelEffect': channelEffect.index,
      'damageSchool': damageSchool.index,
      'appliesPermanentVulnerability': appliesPermanentVulnerability,
    };
  }

  /// Creates an AbilityData from a JSON map (for loading overrides)
  factory AbilityData.fromJson(Map<String, dynamic> json) {
    return AbilityData(
      name: json['name'] as String,
      description: json['description'] as String? ?? '',
      type: AbilityType.values[json['type'] as int? ?? 0],
      damage: (json['damage'] as num?)?.toDouble() ?? 0.0,
      cooldown: (json['cooldown'] as num?)?.toDouble() ?? 1.0,
      duration: (json['duration'] as num?)?.toDouble() ?? 0.0,
      range: (json['range'] as num?)?.toDouble() ?? 0.0,
      color: json['color'] != null
          ? Vector3(
              (json['color'][0] as num).toDouble(),
              (json['color'][1] as num).toDouble(),
              (json['color'][2] as num).toDouble(),
            )
          : Vector3(1.0, 1.0, 1.0),
      impactColor: json['impactColor'] != null
          ? Vector3(
              (json['impactColor'][0] as num).toDouble(),
              (json['impactColor'][1] as num).toDouble(),
              (json['impactColor'][2] as num).toDouble(),
            )
          : Vector3(1.0, 1.0, 1.0),
      impactSize: (json['impactSize'] as num?)?.toDouble() ?? 0.5,
      projectileSpeed: (json['projectileSpeed'] as num?)?.toDouble() ?? 0.0,
      projectileSize: (json['projectileSize'] as num?)?.toDouble() ?? 0.0,
      healAmount: (json['healAmount'] as num?)?.toDouble() ?? 0.0,
      manaColor: ManaColor.values[(json['manaColor'] as int? ?? 0).clamp(0, ManaColor.values.length - 1)],
      manaCost: (json['manaCost'] as num?)?.toDouble() ?? 0.0,
      secondaryManaColor: ManaColor.values[(json['secondaryManaColor'] as int? ?? 0).clamp(0, ManaColor.values.length - 1)],
      secondaryManaCost: (json['secondaryManaCost'] as num?)?.toDouble() ?? 0.0,
      statusEffect: StatusEffect.values[json['statusEffect'] as int? ?? 0],
      statusDuration: (json['statusDuration'] as num?)?.toDouble() ?? 0.0,
      statusStrength: (json['statusStrength'] as num?)?.toDouble() ?? 0.0,
      aoeRadius: (json['aoeRadius'] as num?)?.toDouble() ?? 0.0,
      dotTicks: json['dotTicks'] as int? ?? 0,
      knockbackForce: (json['knockbackForce'] as num?)?.toDouble() ?? 0.0,
      piercing: json['piercing'] as bool? ?? false,
      maxTargets: json['maxTargets'] as int? ?? 1,
      castTime: (json['castTime'] as num?)?.toDouble() ?? 0.0,
      category: json['category'] as String? ?? 'general',
      windupTime: (json['windupTime'] as num?)?.toDouble() ?? 0.0,
      windupMovementSpeed: (json['windupMovementSpeed'] as num?)?.toDouble() ?? 1.0,
      hitRadius: (json['hitRadius'] as num?)?.toDouble(),
      requiresStationary: json['requiresStationary'] as bool? ?? false,
      channelEffect: ChannelEffect.values[(json['channelEffect'] as int? ?? 0).clamp(0, ChannelEffect.values.length - 1)],
      damageSchool: DamageSchool.values[(json['damageSchool'] as int? ?? 0).clamp(0, DamageSchool.values.length - 1)],
      appliesPermanentVulnerability: json['appliesPermanentVulnerability'] as bool? ?? false,
    );
  }

  /// Applies a sparse override map to this ability, returning a new AbilityData
  /// Only fields present in the overrides map are changed
  AbilityData applyOverrides(Map<String, dynamic> overrides) {
    return copyWith(
      description: overrides['description'] as String?,
      type: overrides['type'] != null ? AbilityType.values[overrides['type'] as int] : null,
      damage: (overrides['damage'] as num?)?.toDouble(),
      cooldown: (overrides['cooldown'] as num?)?.toDouble(),
      duration: (overrides['duration'] as num?)?.toDouble(),
      range: (overrides['range'] as num?)?.toDouble(),
      color: overrides['color'] != null
          ? Vector3(
              (overrides['color'][0] as num).toDouble(),
              (overrides['color'][1] as num).toDouble(),
              (overrides['color'][2] as num).toDouble(),
            )
          : null,
      impactColor: overrides['impactColor'] != null
          ? Vector3(
              (overrides['impactColor'][0] as num).toDouble(),
              (overrides['impactColor'][1] as num).toDouble(),
              (overrides['impactColor'][2] as num).toDouble(),
            )
          : null,
      impactSize: (overrides['impactSize'] as num?)?.toDouble(),
      projectileSpeed: (overrides['projectileSpeed'] as num?)?.toDouble(),
      projectileSize: (overrides['projectileSize'] as num?)?.toDouble(),
      healAmount: (overrides['healAmount'] as num?)?.toDouble(),
      manaColor: overrides['manaColor'] != null ? ManaColor.values[overrides['manaColor'] as int] : null,
      manaCost: (overrides['manaCost'] as num?)?.toDouble(),
      secondaryManaColor: overrides['secondaryManaColor'] != null ? ManaColor.values[overrides['secondaryManaColor'] as int] : null,
      secondaryManaCost: (overrides['secondaryManaCost'] as num?)?.toDouble(),
      statusEffect: overrides['statusEffect'] != null ? StatusEffect.values[overrides['statusEffect'] as int] : null,
      statusDuration: (overrides['statusDuration'] as num?)?.toDouble(),
      statusStrength: (overrides['statusStrength'] as num?)?.toDouble(),
      aoeRadius: (overrides['aoeRadius'] as num?)?.toDouble(),
      dotTicks: overrides['dotTicks'] as int?,
      knockbackForce: (overrides['knockbackForce'] as num?)?.toDouble(),
      piercing: overrides['piercing'] as bool?,
      maxTargets: overrides['maxTargets'] as int?,
      castTime: (overrides['castTime'] as num?)?.toDouble(),
      category: overrides['category'] as String?,
      windupTime: (overrides['windupTime'] as num?)?.toDouble(),
      windupMovementSpeed: (overrides['windupMovementSpeed'] as num?)?.toDouble(),
      hitRadius: (overrides['hitRadius'] as num?)?.toDouble(),
      requiresStationary: overrides['requiresStationary'] as bool?,
      channelEffect: overrides['channelEffect'] != null ? ChannelEffect.values[overrides['channelEffect'] as int] : null,
      damageSchool: overrides['damageSchool'] != null ? DamageSchool.values[overrides['damageSchool'] as int] : null,
      appliesPermanentVulnerability: overrides['appliesPermanentVulnerability'] as bool?,
    );
  }
}
