import 'package:vector_math/vector_math.dart' hide Colors;
import '../../rendering3d/mesh.dart';
import '../../rendering3d/math/transform3d.dart';
import '../../rendering3d/terrain_generator.dart';
import '../../rendering3d/heightmap.dart';
import '../../rendering3d/infinite_terrain_manager.dart';
import '../../rendering3d/ley_lines.dart';
import '../../models/projectile.dart';
import '../../models/impact_effect.dart';
import '../ui/damage_indicators.dart';
import '../../models/ally.dart';
import '../../models/ai_chat_message.dart';
import '../../models/monster.dart';
import '../../models/monster_ontology.dart';
import '../../models/inventory.dart';
import '../../models/item.dart';
import '../../models/damage_event.dart';
import '../../models/target_dummy.dart';
import '../../data/item_database.dart';
import 'game_config.dart';
import 'mana_config.dart';
import '../utils/movement_prediction.dart';
import '../utils/bezier_path.dart';
import '../ai/tactical_positioning.dart';
import '../data/monsters/minion_definitions.dart';

/// Game State - Centralized state management for the 3D game
///
/// This class holds all mutable game state including:
/// - Player state (position, rotation, abilities, health)
/// - Monster state (position, rotation, abilities, health, AI)
/// - Ally state
/// - Projectiles and visual effects
/// - Game loop state (frame count, timing)
class GameState {
  // ==================== TERRAIN ====================

  // Old terrain system (for backwards compatibility)
  List<TerrainTile>? terrainTiles;
  Heightmap? terrainHeightmap; // For collision detection

  // New infinite terrain system with LOD
  InfiniteTerrainManager? infiniteTerrainManager;

  // ==================== PLAYER STATE ====================

  Mesh? playerMesh;
  Transform3d? playerTransform;
  Mesh? directionIndicator;
  Transform3d? directionIndicatorTransform;
  Mesh? shadowMesh;
  Transform3d? shadowTransform;

  double playerRotation = GameConfig.playerStartRotation;
  double playerSpeed = GameConfig.playerSpeed;

  // Player health
  double playerHealth = 100.0;
  final double playerMaxHealth = 100.0;

  // ==================== PLAYER MANA ====================

  /// Blue mana - regenerated near Ley Lines
  double blueMana = 100.0;
  double get maxBlueMana => globalManaConfig?.maxBlueMana ?? 100.0;

  /// Red mana - generated by melee damage and Ley Power nodes
  /// Characters start with 0 red mana
  double redMana = 0.0;
  double get maxRedMana => globalManaConfig?.maxRedMana ?? 100.0;

  /// Time elapsed since last red mana gain or spend (for decay grace period)
  double _timeSinceLastRedManaChange = 0.0;

  /// Current mana regeneration rate (updated based on Ley Line proximity)
  double currentManaRegenRate = 0.0;

  /// Current red mana regeneration rate (from power nodes only)
  double currentRedManaRegenRate = 0.0;

  /// Ley Line info for current position (for UI display)
  LeyLineInfo? currentLeyLineInfo;

  /// Whether player is currently on a Ley Power node
  bool isOnPowerNode = false;

  /// Spend blue mana for an ability
  /// Returns true if mana was spent, false if not enough mana
  bool spendBlueMana(double amount) {
    if (blueMana >= amount) {
      blueMana -= amount;
      return true;
    }
    return false;
  }

  /// Check if player has enough blue mana
  bool hasBlueMana(double amount) => blueMana >= amount;

  /// Spend red mana for an ability
  /// Returns true if mana was spent, false if not enough mana
  bool spendRedMana(double amount) {
    if (redMana >= amount) {
      redMana -= amount;
      _timeSinceLastRedManaChange = 0.0; // Reset decay timer on spend
      return true;
    }
    return false;
  }

  /// Check if player has enough red mana
  bool hasRedMana(double amount) => redMana >= amount;

  /// Generate red mana from dealing melee damage
  /// Amount is proportional to damage dealt (default 20% of damage = red mana)
  void generateRedManaFromMelee(double damageDealt) {
    final manaPerDamage = globalManaConfig?.manaPerDamage ?? 0.2;
    final manaGained = damageDealt * manaPerDamage;
    redMana = (redMana + manaGained).clamp(0.0, maxRedMana);
    if (manaGained > 0) {
      _timeSinceLastRedManaChange = 0.0; // Reset decay timer on gain
      print('[MANA] Generated ${manaGained.toStringAsFixed(1)} red mana from melee damage');
    }
  }

  /// Regenerate mana based on current position
  void updateManaRegen(double dt) {
    if (leyLineManager == null || playerTransform == null) return;

    final pos = playerTransform!.position;
    currentManaRegenRate = leyLineManager!.calculateManaRegen(pos.x, pos.z);
    currentLeyLineInfo = leyLineManager!.getLeyLineInfo(pos.x, pos.z);

    // Check if on a power node
    isOnPowerNode = leyLineManager!.isOnPowerNode(pos.x, pos.z);

    // Apply blue mana regeneration (always near Ley Lines)
    if (currentManaRegenRate > 0) {
      blueMana = (blueMana + currentManaRegenRate * dt).clamp(0.0, maxBlueMana);
    }

    // Apply red mana regeneration (only on power nodes)
    // On power nodes, ALL mana types regenerate at the same rate as blue mana
    if (isOnPowerNode) {
      currentRedManaRegenRate = currentManaRegenRate;
      redMana = (redMana + currentManaRegenRate * dt).clamp(0.0, maxRedMana);
      _timeSinceLastRedManaChange = 0.0; // Power nodes pause decay
    } else {
      currentRedManaRegenRate = 0.0;

      // Red mana decay (after grace period, when not on power node)
      if (redMana > 0) {
        _timeSinceLastRedManaChange += dt;
        final decayDelay = globalManaConfig?.redManaDecayDelay ?? 5.0;
        if (_timeSinceLastRedManaChange >= decayDelay) {
          final decayRate = globalManaConfig?.redManaDecayRate ?? 3.0;
          redMana = (redMana - decayRate * dt).clamp(0.0, maxRedMana);
        }
      }
    }
  }

  // ==================== LEY LINES ====================

  /// Ley Lines manager - generates and manages magical energy lines
  LeyLineManager? leyLineManager;

  /// Initialize Ley Lines for the world
  void initializeLeyLines({int seed = 42, double worldSize = 200.0, int siteCount = 25}) {
    leyLineManager = LeyLineManager(
      seed: seed,
      worldSize: worldSize,
      siteCount: siteCount,
    );
    print('[LeyLines] Initialized with seed $seed, ${leyLineManager!.segments.length} segments');
  }

  // ==================== MONSTER STATE ====================

  Mesh? monsterMesh;
  Transform3d? monsterTransform;
  Mesh? monsterDirectionIndicator;
  Transform3d? monsterDirectionIndicatorTransform;
  double monsterRotation = 180.0; // Face toward player initially

  // Monster health and abilities
  double monsterHealth = GameConfig.monsterMaxHealth;
  final double monsterMaxHealth = GameConfig.monsterMaxHealth;
  double monsterAbility1Cooldown = 0.0;
  final double monsterAbility1CooldownMax = GameConfig.monsterAbility1CooldownMax;
  double monsterAbility2Cooldown = 0.0;
  final double monsterAbility2CooldownMax = GameConfig.monsterAbility2CooldownMax;
  double monsterAbility3Cooldown = 0.0;
  final double monsterAbility3CooldownMax = GameConfig.monsterAbility3CooldownMax;

  // Monster AI state
  bool monsterPaused = false;
  double monsterAiTimer = 0.0;
  final double monsterAiInterval = GameConfig.monsterAiInterval;
  List<Projectile> monsterProjectiles = [];

  // Monster movement and pathfinding
  BezierPath? monsterCurrentPath;
  double monsterMoveSpeed = 3.0; // Units per second
  String monsterCurrentStrategy = 'BALANCED'; // Current combat strategy

  // Monster sword state (for melee ability 1)
  Mesh? monsterSwordMesh;
  Transform3d? monsterSwordTransform;
  bool monsterAbility1Active = false;
  double monsterAbility1ActiveTime = 0.0;
  bool monsterAbility1HitRegistered = false;

  // ==================== ALLY STATE ====================

  List<Ally> allies = []; // Start with zero allies
  FormationType currentFormation = FormationType.scattered; // Active formation
  Map<Ally, TacticalPosition>? _cachedTacticalPositions;
  double _tacticalPositionCacheTime = 0.0;

  /// Get tactical positions for all allies (cached for performance)
  Map<Ally, TacticalPosition> getTacticalPositions() {
    // Recalculate every 0.5 seconds or when cache is invalid
    final now = DateTime.now().millisecondsSinceEpoch / 1000.0;
    if (_cachedTacticalPositions == null ||
        now - _tacticalPositionCacheTime > 0.5) {
      _cachedTacticalPositions = TacticalPositioning.calculatePositions(
        this,
        currentFormation,
      );
      _tacticalPositionCacheTime = now;
    }
    return _cachedTacticalPositions!;
  }

  /// Force recalculation of tactical positions
  void invalidateTacticalPositions() {
    _cachedTacticalPositions = null;
  }

  // ==================== MINIONS STATE ====================

  /// List of active minion instances
  List<Monster> minions = [];

  /// Whether minions have been spawned this session
  bool minionsSpawned = false;

  /// Direction indicator meshes for minions (shared by type)
  final Map<String, Mesh> _minionDirectionIndicators = {};

  /// Get or create direction indicator mesh for a minion type
  Mesh getMinionDirectionIndicator(MonsterDefinition definition) {
    return _minionDirectionIndicators.putIfAbsent(
      definition.id,
      () => Mesh.triangle(
        size: 0.3 * definition.effectiveScale,
        color: definition.accentColor,
      ),
    );
  }

  /// Spawn all minions according to DefaultMinionSpawns configuration
  /// Total: 8 Goblin Rogues + 4 Orc Warlocks + 2 Cultist Priests + 1 Skeleton Champion = 15 minions
  void spawnMinions(InfiniteTerrainManager? terrainManager) {
    if (minionsSpawned) return;

    print('[MINIONS] Spawning minions...');
    print(DefaultMinionSpawns.summary);

    // Base spawn position (offset from monster)
    final baseX = GameConfig.monsterStartPosition.x;
    final baseZ = GameConfig.monsterStartPosition.z - 10; // Behind the boss

    int totalSpawned = 0;

    for (final spawnConfig in DefaultMinionSpawns.spawns) {
      final definition = MinionDefinitions.getById(spawnConfig.definitionId);
      if (definition == null) {
        print('[MINIONS] Warning: Unknown definition ${spawnConfig.definitionId}');
        continue;
      }

      // Calculate spawn center for this group (arrange groups in a line)
      final groupOffset = totalSpawned * 0.5;
      final centerX = baseX + (groupOffset % 4) * 4 - 6;
      final centerZ = baseZ - (groupOffset ~/ 4) * 4;

      // Get terrain height at spawn center
      double centerY = 0.0;
      if (terrainManager != null) {
        centerY = terrainManager.getTerrainHeight(centerX, centerZ);
      }

      // Create monsters for this group
      final monsters = MonsterFactory.createGroup(
        definition: definition,
        centerPosition: Vector3(centerX, centerY, centerZ),
        count: spawnConfig.count,
        spreadRadius: spawnConfig.spreadRadius,
      );

      // Adjust Y positions to terrain height (add half size so bottom sits on terrain)
      for (final monster in monsters) {
        if (terrainManager != null) {
          final terrainY = terrainManager.getTerrainHeight(
            monster.transform.position.x,
            monster.transform.position.z,
          );
          // Add half the minion size + buffer so bottom of mesh sits above terrain
          const double terrainBuffer = 0.15;
          monster.transform.position.y = terrainY + definition.effectiveScale / 2 + terrainBuffer;
          // Direction indicator sits on top of the mesh
          if (monster.directionIndicatorTransform != null) {
            monster.directionIndicatorTransform!.position.y =
                monster.transform.position.y + definition.effectiveScale / 2 + 0.1;
          }
        }
      }

      minions.addAll(monsters);
      totalSpawned += spawnConfig.count;

      print('[MINIONS] Spawned ${spawnConfig.count}x ${definition.name} '
          '(MP ${definition.monsterPower})');
    }

    minionsSpawned = true;
    print('[MINIONS] Total spawned: ${minions.length} minions');
    print('[MINIONS] Total Monster Power: ${DefaultMinionSpawns.totalMonsterPower}');
  }

  /// Get all alive minions
  List<Monster> get aliveMinions => minions.where((m) => m.isAlive).toList();

  /// Get minions by archetype
  List<Monster> getMinionsByArchetype(MonsterArchetype archetype) {
    return minions.where((m) =>
        m.isAlive && m.definition.archetype == archetype).toList();
  }

  /// Get the nearest minion to a position
  Monster? getNearestMinion(Vector3 position, {double maxRange = double.infinity}) {
    Monster? nearest;
    double nearestDist = maxRange;

    for (final minion in aliveMinions) {
      final dist = minion.distanceTo(position);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = minion;
      }
    }

    return nearest;
  }

  // ==================== AI CHAT ====================

  List<AIChatMessage> monsterAIChat = [];

  // ==================== TARGETING STATE ====================

  /// Current player target ID ('boss' for main monster, or minion instanceId)
  String? currentTargetId;

  /// Target indicator mesh (yellow dashed rectangle)
  Mesh? targetIndicatorMesh;
  Transform3d? targetIndicatorTransform;
  double lastTargetIndicatorSize = 0.0; // Track size for recreation

  /// Index for tab targeting cycle
  int _tabTargetIndex = -1;

  /// Cached list of targetable enemies for tab cycling
  List<String> _targetableEnemyIds = [];
  double _targetListCacheTime = 0.0;

  /// Get the currently targeted entity
  /// Returns a map with 'type' ('boss', 'minion', or 'dummy') and the entity itself
  Map<String, dynamic>? getCurrentTarget() {
    if (currentTargetId == null) return null;

    if (currentTargetId == 'boss') {
      return {
        'type': 'boss',
        'entity': null, // Boss is accessed directly via gameState
        'id': 'boss',
      };
    }

    // Check for target dummy
    if (currentTargetId == TargetDummy.instanceId && targetDummy != null && targetDummy!.isSpawned) {
      return {
        'type': 'dummy',
        'entity': targetDummy,
        'id': TargetDummy.instanceId,
      };
    }

    // Find minion by instance ID
    final minion = minions.firstWhere(
      (m) => m.instanceId == currentTargetId && m.isAlive,
      orElse: () => minions.firstWhere((m) => false, orElse: () => minions.first),
    );

    if (minion.instanceId == currentTargetId && minion.isAlive) {
      return {
        'type': 'minion',
        'entity': minion,
        'id': currentTargetId,
      };
    }

    // Target is dead or invalid, clear it
    currentTargetId = null;
    return null;
  }

  /// Get XZ-plane distance from player to current target
  /// Returns null if no target or no player position
  double? getDistanceToCurrentTarget() {
    if (currentTargetId == null || playerTransform == null) return null;

    final playerPos = playerTransform!.position;

    if (currentTargetId == 'boss') {
      if (monsterTransform != null && monsterHealth > 0) {
        final dx = monsterTransform!.position.x - playerPos.x;
        final dz = monsterTransform!.position.z - playerPos.z;
        return sqrt(dx * dx + dz * dz);
      }
      return null;
    }

    if (currentTargetId == TargetDummy.instanceId && targetDummy != null && targetDummy!.isSpawned) {
      return targetDummy!.distanceToXZ(playerPos);
    }

    // Check minions
    for (final minion in aliveMinions) {
      if (minion.instanceId == currentTargetId) {
        final dx = minion.transform.position.x - playerPos.x;
        final dz = minion.transform.position.z - playerPos.z;
        return sqrt(dx * dx + dz * dz);
      }
    }

    return null;
  }

  /// Get target's current target (target of target)
  String? getTargetOfTarget() {
    final target = getCurrentTarget();
    if (target == null) return null;

    if (target['type'] == 'boss') {
      // Boss always targets player (for now)
      return 'player';
    } else if (target['type'] == 'minion') {
      final minion = target['entity'] as Monster;
      return minion.targetId ?? 'none';
    } else if (target['type'] == 'dummy') {
      // Dummy doesn't target anyone
      return 'none';
    }

    return null;
  }

  /// Set the current target by ID
  void setTarget(String? targetId) {
    currentTargetId = targetId;
    // Update tab index to match
    if (targetId != null) {
      final index = _targetableEnemyIds.indexOf(targetId);
      if (index >= 0) {
        _tabTargetIndex = index;
      }
    }
  }

  /// Clear current target
  void clearTarget() {
    currentTargetId = null;
    _tabTargetIndex = -1;
  }

  /// Get ordered list of targetable enemies (for tab targeting)
  /// Sorted by angle from player's facing direction, then by distance
  List<String> getTargetableEnemies(double playerX, double playerZ, double playerRotation) {
    final now = DateTime.now().millisecondsSinceEpoch / 1000.0;

    // Cache for 0.2 seconds
    if (_targetableEnemyIds.isNotEmpty && now - _targetListCacheTime < 0.2) {
      return _targetableEnemyIds;
    }

    final targets = <_TargetCandidate>[];
    final playerFacingRad = playerRotation * 3.14159 / 180.0;
    final playerFacingX = -sin(playerFacingRad);
    final playerFacingZ = -cos(playerFacingRad);

    // Add target dummy if spawned (prioritize for DPS testing)
    if (targetDummy != null && targetDummy!.isSpawned) {
      final dx = targetDummy!.position.x - playerX;
      final dz = targetDummy!.position.z - playerZ;
      final dist = sqrt(dx * dx + dz * dz);
      final angle = _calculateAngleToTarget(dx, dz, playerFacingX, playerFacingZ, dist);
      targets.add(_TargetCandidate(TargetDummy.instanceId, dist, angle));
    }

    // Add boss if alive
    if (monsterHealth > 0 && monsterTransform != null) {
      final dx = monsterTransform!.position.x - playerX;
      final dz = monsterTransform!.position.z - playerZ;
      final dist = sqrt(dx * dx + dz * dz);
      final angle = _calculateAngleToTarget(dx, dz, playerFacingX, playerFacingZ, dist);
      targets.add(_TargetCandidate('boss', dist, angle));
    }

    // Add alive minions
    for (final minion in aliveMinions) {
      final dx = minion.transform.position.x - playerX;
      final dz = minion.transform.position.z - playerZ;
      final dist = sqrt(dx * dx + dz * dz);
      final angle = _calculateAngleToTarget(dx, dz, playerFacingX, playerFacingZ, dist);
      targets.add(_TargetCandidate(minion.instanceId, dist, angle));
    }

    // Sort: prioritize enemies in front (small angle), then by distance
    // Cone preference: enemies within 60 degrees of facing direction get priority
    targets.sort((a, b) {
      final aInCone = a.angle < 60;
      final bInCone = b.angle < 60;

      if (aInCone && !bInCone) return -1;
      if (!aInCone && bInCone) return 1;

      // Within same cone status, sort by angle first, then distance
      if (aInCone && bInCone) {
        final angleDiff = a.angle - b.angle;
        if (angleDiff.abs() > 10) return angleDiff.toInt();
      }

      return (a.distance - b.distance).sign.toInt();
    });

    _targetableEnemyIds = targets.map((t) => t.id).toList();
    _targetListCacheTime = now;

    return _targetableEnemyIds;
  }

  /// Calculate angle (in degrees) between player facing and target direction
  double _calculateAngleToTarget(double dx, double dz, double facingX, double facingZ, double dist) {
    if (dist < 0.001) return 0;
    final targetDirX = dx / dist;
    final targetDirZ = dz / dist;
    final dot = facingX * targetDirX + facingZ * targetDirZ;
    final clampedDot = dot.clamp(-1.0, 1.0);
    return acos(clampedDot) * 180.0 / 3.14159;
  }

  /// Tab to next target (WoW-style)
  void tabToNextTarget(double playerX, double playerZ, double playerRotation, {bool reverse = false}) {
    final targets = getTargetableEnemies(playerX, playerZ, playerRotation);
    if (targets.isEmpty) {
      clearTarget();
      return;
    }

    if (reverse) {
      _tabTargetIndex--;
      if (_tabTargetIndex < 0) _tabTargetIndex = targets.length - 1;
    } else {
      _tabTargetIndex++;
      if (_tabTargetIndex >= targets.length) _tabTargetIndex = 0;
    }

    currentTargetId = targets[_tabTargetIndex];
  }

  /// Check if a specific entity is the current target
  bool isTargeted(String id) => currentTargetId == id;

  /// Validate current target (clear if dead)
  void validateTarget() {
    if (currentTargetId == null) return;

    if (currentTargetId == 'boss') {
      if (monsterHealth <= 0) clearTarget();
    } else if (currentTargetId == TargetDummy.instanceId) {
      // Target dummy is valid as long as it's spawned
      if (targetDummy == null || !targetDummy!.isSpawned) clearTarget();
    } else {
      final minion = minions.where((m) => m.instanceId == currentTargetId).firstOrNull;
      if (minion == null || !minion.isAlive) clearTarget();
    }
  }

  // Math helpers for targeting
  static double sqrt(double x) => x <= 0 ? 0 : _sqrtNewton(x);
  static double _sqrtNewton(double x) {
    double guess = x / 2;
    for (int i = 0; i < 10; i++) {
      guess = (guess + x / guess) / 2;
    }
    return guess;
  }
  static double sin(double x) {
    while (x > 3.14159) x -= 2 * 3.14159;
    while (x < -3.14159) x += 2 * 3.14159;
    final x2 = x * x;
    return x - x * x2 / 6 + x * x2 * x2 / 120;
  }
  static double cos(double x) {
    while (x > 3.14159) x -= 2 * 3.14159;
    while (x < -3.14159) x += 2 * 3.14159;
    final x2 = x * x;
    return 1 - x2 / 2 + x2 * x2 / 24;
  }
  static double acos(double x) {
    // Simple approximation for acos
    if (x >= 1) return 0;
    if (x <= -1) return 3.14159;
    return 3.14159 / 2 - _asinApprox(x);
  }
  static double _asinApprox(double x) {
    // Approximation: asin(x) ≈ x + x³/6 + 3x⁵/40
    final x3 = x * x * x;
    final x5 = x3 * x * x;
    return x + x3 / 6 + 3 * x5 / 40;
  }

  // ==================== UI STATE ====================

  /// Whether the abilities modal is currently open
  bool abilitiesModalOpen = false;

  /// Whether the character panel is currently open
  bool characterPanelOpen = false;

  /// Whether the bag/inventory panel is currently open
  bool bagPanelOpen = false;

  /// Whether the DPS testing panel is currently open
  bool dpsPanelOpen = false;

  // ==================== DPS TESTING STATE ====================

  /// DPS tracker for measuring damage output
  final DpsTracker dpsTracker = DpsTracker();

  /// Target dummy for DPS testing (null when not spawned)
  TargetDummy? targetDummy;

  /// Spawn a target dummy 40 yards in front of the player
  void spawnTargetDummy(InfiniteTerrainManager? terrainManager) {
    if (targetDummy != null && targetDummy!.isSpawned) return;
    if (playerTransform == null) return;

    // Calculate position 40 yards (units) in front of the player
    final playerPos = playerTransform!.position;
    final playerRot = playerRotation * 3.14159 / 180.0;

    // Direction player is facing
    final dirX = -sin(playerRot);
    final dirZ = -cos(playerRot);

    // Position 40 units ahead
    const distance = 40.0;
    final dummyX = playerPos.x + dirX * distance;
    final dummyZ = playerPos.z + dirZ * distance;

    // Get terrain height at dummy position
    double dummyY = playerPos.y;
    if (terrainManager != null) {
      final terrainHeight = terrainManager.getTerrainHeight(dummyX, dummyZ);
      dummyY = terrainHeight + TargetDummy.size / 2 + 0.15;
    }

    targetDummy = TargetDummy.spawn(Vector3(dummyX, dummyY, dummyZ));

    // Start DPS tracking session
    dpsTracker.startSession();

    print('[DPS] Target Dummy spawned at ($dummyX, $dummyY, $dummyZ)');
  }

  /// Despawn the target dummy
  void despawnTargetDummy() {
    if (targetDummy == null) return;

    targetDummy!.isSpawned = false;
    targetDummy = null;

    // End DPS tracking session
    dpsTracker.endSession();

    print('[DPS] Target Dummy despawned');
  }

  /// Check if target dummy is the current target
  bool get isTargetingDummy => currentTargetId == TargetDummy.instanceId;

  // ==================== INVENTORY STATE ====================

  /// Player inventory (equipment and bag)
  final Inventory playerInventory = Inventory();

  /// Whether the inventory has been initialized with items
  bool inventoryInitialized = false;

  /// Initialize player inventory with sample items from database
  Future<void> initializeInventory() async {
    if (inventoryInitialized) return;

    // Load the item database
    await ItemDatabase.instance.load();

    // Add sample items to bag
    final sampleItems = [
      'health_potion',
      'health_potion',
      'mana_potion',
      'iron_sword',
      'chainmail_armor',
      'iron_helm',
      'leather_boots',
      'leather_gloves',
      'iron_greaves',
      'travelers_cloak',
      'wooden_shield',
      'ring_of_strength',
      'iron_ore',
      'gold_coin',
      'dragon_scale',
    ];

    for (final itemId in sampleItems) {
      final item = ItemDatabase.instance.createItem(itemId);
      if (item != null) {
        playerInventory.addToBag(item);
      }
    }

    // Pre-equip some items on the player
    final startingEquipment = [
      'steel_plate',
      'steel_helm',
      'war_axe',
      'tower_shield',
      'boots_of_swiftness',
      'gauntlets_of_might',
      'legplates_of_valor',
      'cloak_of_shadows',
      'signet_of_the_warchief',
      'band_of_protection',
    ];

    for (final itemId in startingEquipment) {
      final item = ItemDatabase.instance.createItem(itemId);
      if (item != null && item.isEquippable) {
        playerInventory.equip(item);
      }
    }

    inventoryInitialized = true;
    print('[GameState] Inventory initialized with ${playerInventory.usedBagSlots} bag items and equipment');
  }

  // ==================== JUMP/PHYSICS STATE ====================

  bool isJumping = false;
  double verticalVelocity = 0.0;
  bool isGrounded = true;
  int jumpsRemaining = 2; // Allow 2 jumps total (ground jump + air jump)
  final int maxJumps = 2;
  final double jumpForce = GameConfig.jumpVelocity;
  final double gravity = GameConfig.gravity;
  final double groundLevel = GameConfig.groundLevel;
  bool jumpKeyWasPressed = false; // Track previous jump key state

  // ==================== CASTING/WINDUP STATE ====================

  /// Whether the player is currently casting a spell with cast time
  bool isCasting = false;

  /// Current cast progress in seconds (0 to castTime)
  double castProgress = 0.0;

  /// The total cast time of the current spell being cast
  double currentCastTime = 0.0;

  /// The slot index of the ability being cast
  int? castingSlotIndex;

  /// Name of the ability being cast (for UI display)
  String castingAbilityName = '';

  /// Whether the player is currently winding up a melee attack
  bool isWindingUp = false;

  /// Current windup progress in seconds (0 to windupTime)
  double windupProgress = 0.0;

  /// The total windup time of the current melee attack
  double currentWindupTime = 0.0;

  /// The slot index of the ability being wound up
  int? windupSlotIndex;

  /// Name of the ability being wound up (for UI display)
  String windupAbilityName = '';

  /// Movement speed modifier from windup (0.0 = stopped, 1.0 = full speed)
  double windupMovementSpeedModifier = 1.0;

  /// Pending mana cost to spend when cast/windup completes.
  /// If interrupted, cost is not spent.
  double pendingManaCost = 0.0;

  /// Whether the pending mana is blue (true) or red (false)
  bool pendingManaIsBlue = true;

  /// Get the effective movement speed considering windup modifier
  double get effectivePlayerSpeed => playerSpeed * windupMovementSpeedModifier;

  /// Cancel any active cast (called when player moves during stationary cast)
  void cancelCast() {
    if (isCasting) {
      print('[CAST] $castingAbilityName cast cancelled — mana and cooldown preserved');
      isCasting = false;
      castProgress = 0.0;
      currentCastTime = 0.0;
      castingSlotIndex = null;
      castingAbilityName = '';
      pendingManaCost = 0.0;
    }
  }

  /// Cancel any active windup
  void cancelWindup() {
    if (isWindingUp) {
      print('[WINDUP] $windupAbilityName windup cancelled — mana and cooldown preserved');
      isWindingUp = false;
      windupProgress = 0.0;
      currentWindupTime = 0.0;
      windupSlotIndex = null;
      windupAbilityName = '';
      windupMovementSpeedModifier = 1.0;
      pendingManaCost = 0.0;
    }
  }

  /// Check if player is performing any cast/windup action
  bool get isPerformingAction => isCasting || isWindingUp;

  /// Get cast progress as percentage (0.0 to 1.0)
  double get castPercentage => currentCastTime > 0 ? castProgress / currentCastTime : 0.0;

  /// Get windup progress as percentage (0.0 to 1.0)
  double get windupPercentage => currentWindupTime > 0 ? windupProgress / currentWindupTime : 0.0;

  // ==================== ABILITY 1: SWORD ====================

  double ability1Cooldown = 0.0;
  final double ability1CooldownMax = GameConfig.ability1CooldownMax;
  bool ability1Active = false;
  double ability1ActiveTime = 0.0;
  final double ability1Duration = GameConfig.ability1Duration;
  bool ability1HitRegistered = false; // Prevent multiple hits per swing
  Mesh? swordMesh;
  Transform3d? swordTransform;

  // ==================== ABILITY 2: FIREBALL ====================

  double ability2Cooldown = 0.0;
  final double ability2CooldownMax = GameConfig.ability2CooldownMax;
  List<Projectile> fireballs = []; // List of active fireballs

  // ==================== ABILITY 3: HEAL ====================

  double ability3Cooldown = 0.0;
  final double ability3CooldownMax = GameConfig.ability3CooldownMax;
  bool ability3Active = false;
  double ability3ActiveTime = 0.0;
  final double ability3Duration = 1.0; // Heal effect duration
  Mesh? healEffectMesh;
  Transform3d? healEffectTransform;

  // ==================== ABILITY 4: DASH ATTACK ====================

  double ability4Cooldown = 0.0;
  final double ability4CooldownMax = 6.0; // 6 second cooldown
  bool ability4Active = false;
  double ability4ActiveTime = 0.0;
  final double ability4Duration = 0.4; // Dash duration
  bool ability4HitRegistered = false; // Prevent multiple hits per dash
  Mesh? dashTrailMesh;
  Transform3d? dashTrailTransform;

  // ==================== ABILITIES 5-10 (Extended Action Bar) ====================

  double ability5Cooldown = 0.0;
  final double ability5CooldownMax = 5.0;

  double ability6Cooldown = 0.0;
  final double ability6CooldownMax = 5.0;

  double ability7Cooldown = 0.0;
  final double ability7CooldownMax = 5.0;

  double ability8Cooldown = 0.0;
  final double ability8CooldownMax = 5.0;

  double ability9Cooldown = 0.0;
  final double ability9CooldownMax = 5.0;

  double ability10Cooldown = 0.0;
  final double ability10CooldownMax = 5.0;

  // ==================== VISUAL EFFECTS ====================

  List<ImpactEffect> impactEffects = []; // List of active impact effects
  List<DamageIndicator> damageIndicators = []; // Floating damage numbers

  // ==================== MOVEMENT TRACKING ====================

  /// Player movement tracker for AI prediction
  final PlayerMovementTracker playerMovementTracker = PlayerMovementTracker();

  // ==================== GAME LOOP STATE ====================

  int? animationFrameId;
  DateTime? lastFrameTime;
  int frameCount = 0;
}

/// Helper class for sorting target candidates
class _TargetCandidate {
  final String id;
  final double distance;
  final double angle; // Angle from player's facing direction

  _TargetCandidate(this.id, this.distance, this.angle);
}
