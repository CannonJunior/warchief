import 'package:vector_math/vector_math.dart' hide Colors;
import '../../rendering3d/mesh.dart';
import '../../rendering3d/math/transform3d.dart';
import '../../rendering3d/terrain_generator.dart';
import '../../rendering3d/heightmap.dart';
import '../../rendering3d/infinite_terrain_manager.dart';
import '../../rendering3d/ley_lines.dart';
import '../../models/projectile.dart';
import '../../models/impact_effect.dart';
import '../ui/damage_indicators.dart';
import '../../models/ally.dart';
import '../../models/ai_chat_message.dart';
import '../../models/monster.dart';
import '../../models/monster_ontology.dart';
import '../../models/inventory.dart';
import '../../models/item.dart';
import '../../models/damage_event.dart';
import '../../models/target_dummy.dart';
import '../../models/building.dart';
import '../../models/goal.dart';
import '../../rendering3d/building_mesh.dart';
import '../../data/item_database.dart';
import 'game_config.dart';
import 'mana_config.dart';
import 'building_config.dart';
import 'wind_config.dart';
import 'wind_state.dart';
import 'minimap_state.dart';
import '../utils/movement_prediction.dart';
import '../utils/bezier_path.dart';
import '../ai/tactical_positioning.dart';
import '../data/monsters/minion_definitions.dart';

/// Game State - Centralized state management for the 3D game
///
/// This class holds all mutable game state including:
/// - Player state (position, rotation, abilities, health)
/// - Monster state (position, rotation, abilities, health, AI)
/// - Ally state
/// - Projectiles and visual effects
/// - Game loop state (frame count, timing)
class GameState {
  // ==================== TERRAIN ====================

  // Old terrain system (for backwards compatibility)
  List<TerrainTile>? terrainTiles;
  Heightmap? terrainHeightmap; // For collision detection

  // New infinite terrain system with LOD
  InfiniteTerrainManager? infiniteTerrainManager;

  // ==================== PLAYER STATE ====================

  Mesh? playerMesh;
  Transform3d? playerTransform;
  Mesh? directionIndicator;
  Transform3d? directionIndicatorTransform;
  Mesh? shadowMesh;
  Transform3d? shadowTransform;

  double playerRotation = GameConfig.playerStartRotation;
  double playerSpeed = GameConfig.playerSpeed;

  // Player health
  double playerHealth = 100.0;
  static const double basePlayerMaxHealth = 100.0;

  /// Max health is base + total health bonus from all equipped items.
  /// This auto-recalculates whenever equipment changes.
  double get playerMaxHealth =>
      basePlayerMaxHealth + playerInventory.totalEquippedStats.health;

  // ==================== PLAYER MANA ====================

  /// Blue mana - regenerated near Ley Lines
  double blueMana = 100.0;
  double get maxBlueMana =>
      (globalManaConfig?.maxBlueMana ?? 100.0) +
      playerInventory.totalEquippedStats.maxBlueMana;

  /// Red mana - generated by melee damage and Ley Power nodes
  /// Characters start with 0 red mana
  double redMana = 0.0;
  double get maxRedMana =>
      (globalManaConfig?.maxRedMana ?? 100.0) +
      playerInventory.totalEquippedStats.maxRedMana;

  /// White mana - regenerated by wind exposure
  double whiteMana = 0.0;
  double get maxWhiteMana =>
      (globalWindConfig?.whiteMaxMana ?? 100.0) +
      playerInventory.totalEquippedStats.maxWhiteMana;

  /// Current white mana regeneration rate (from wind exposure)
  double currentWhiteManaRegenRate = 0.0;

  /// Wind state for wind simulation
  final WindState _windState = WindState();

  /// Expose wind state for rendering and movement systems
  WindState get windState => _windState;

  /// Time elapsed since last red mana gain or spend (for decay grace period)
  double _timeSinceLastRedManaChange = 0.0;

  /// Current mana regeneration rate (updated based on Ley Line proximity)
  double currentManaRegenRate = 0.0;

  /// Current red mana regeneration rate (from power nodes only)
  double currentRedManaRegenRate = 0.0;

  /// Ley Line info for current position (for UI display)
  LeyLineInfo? currentLeyLineInfo;

  /// Whether player is currently on a Ley Power node
  bool isOnPowerNode = false;

  /// Spend blue mana for an ability
  /// Returns true if mana was spent, false if not enough mana
  bool spendBlueMana(double amount) {
    if (blueMana >= amount) {
      blueMana -= amount;
      return true;
    }
    return false;
  }

  /// Check if player has enough blue mana
  bool hasBlueMana(double amount) => blueMana >= amount;

  /// Spend red mana for an ability
  /// Returns true if mana was spent, false if not enough mana
  bool spendRedMana(double amount) {
    if (redMana >= amount) {
      redMana -= amount;
      _timeSinceLastRedManaChange = 0.0; // Reset decay timer on spend
      return true;
    }
    return false;
  }

  /// Check if player has enough red mana
  bool hasRedMana(double amount) => redMana >= amount;

  /// Spend white mana for an ability
  /// Returns true if mana was spent, false if not enough mana
  bool spendWhiteMana(double amount) {
    if (whiteMana >= amount) {
      whiteMana -= amount;
      return true;
    }
    return false;
  }

  /// Check if player has enough white mana
  bool hasWhiteMana(double amount) => whiteMana >= amount;

  /// Generate white mana directly (e.g. from items or abilities)
  void generateWhiteMana(double amount) {
    whiteMana = (whiteMana + amount).clamp(0.0, maxWhiteMana);
  }

  /// Generate red mana from dealing melee damage
  /// Amount is proportional to damage dealt (default 20% of damage = red mana)
  void generateRedManaFromMelee(double damageDealt) {
    final manaPerDamage = globalManaConfig?.manaPerDamage ?? 0.2;
    final manaGained = damageDealt * manaPerDamage;
    redMana = (redMana + manaGained).clamp(0.0, maxRedMana);
    if (manaGained > 0) {
      _timeSinceLastRedManaChange = 0.0; // Reset decay timer on gain
      print('[MANA] Generated ${manaGained.toStringAsFixed(1)} red mana from melee damage');
    }
  }

  /// Regenerate mana based on current position
  void updateManaRegen(double dt) {
    if (leyLineManager == null || playerTransform == null) return;

    final pos = playerTransform!.position;
    currentManaRegenRate = leyLineManager!.calculateManaRegen(pos.x, pos.z);
    currentLeyLineInfo = leyLineManager!.getLeyLineInfo(pos.x, pos.z);

    // Check if on a power node
    isOnPowerNode = leyLineManager!.isOnPowerNode(pos.x, pos.z);

    // Apply blue mana regeneration (Ley Lines + equipped item bonus)
    final blueRegenBonus = playerInventory.totalEquippedStats.blueManaRegen;
    final effectiveBlueRegen = currentManaRegenRate + blueRegenBonus;
    if (effectiveBlueRegen > 0) {
      blueMana = (blueMana + effectiveBlueRegen * dt).clamp(0.0, maxBlueMana);
    }

    // Apply red mana regeneration (power nodes + equipped item bonus)
    final redRegenBonus = playerInventory.totalEquippedStats.redManaRegen;
    if (isOnPowerNode) {
      currentRedManaRegenRate = currentManaRegenRate + redRegenBonus;
      redMana = (redMana + currentRedManaRegenRate * dt).clamp(0.0, maxRedMana);
      _timeSinceLastRedManaChange = 0.0; // Power nodes pause decay
    } else {
      currentRedManaRegenRate = redRegenBonus.toDouble();

      // Apply item-based red regen even off power nodes
      if (redRegenBonus > 0) {
        redMana = (redMana + redRegenBonus * dt).clamp(0.0, maxRedMana);
        _timeSinceLastRedManaChange = 0.0;
      }

      // Red mana decay (after grace period, when not on power node and no item regen)
      if (redMana > 0 && redRegenBonus <= 0) {
        _timeSinceLastRedManaChange += dt;
        final decayDelay = globalManaConfig?.redManaDecayDelay ?? 5.0;
        if (_timeSinceLastRedManaChange >= decayDelay) {
          final decayRate = globalManaConfig?.redManaDecayRate ?? 3.0;
          redMana = (redMana - decayRate * dt).clamp(0.0, maxRedMana);
        }
      }
    }

    // ===== ALLY MANA REGEN =====
    for (final ally in allies) {
      if (ally.health <= 0) continue;

      final allyPos = ally.transform.position;
      final allyBlueRegen = leyLineManager!.calculateManaRegen(allyPos.x, allyPos.z);
      final allyOnPowerNode = leyLineManager!.isOnPowerNode(allyPos.x, allyPos.z);
      final allyItemBlueBonus = ally.inventory.totalEquippedStats.blueManaRegen;
      final allyItemRedBonus = ally.inventory.totalEquippedStats.redManaRegen;

      // Ally blue mana regen (ley lines + item bonus)
      final effectiveAllyBlueRegen = allyBlueRegen + allyItemBlueBonus;
      if (effectiveAllyBlueRegen > 0) {
        ally.blueMana = (ally.blueMana + effectiveAllyBlueRegen * dt)
            .clamp(0.0, ally.maxBlueMana);
      }

      // Ally red mana regen (power nodes + item bonus)
      if (allyOnPowerNode) {
        final allyRedRegen = allyBlueRegen + allyItemRedBonus;
        ally.redMana = (ally.redMana + allyRedRegen * dt)
            .clamp(0.0, ally.maxRedMana);
      } else if (allyItemRedBonus > 0) {
        ally.redMana = (ally.redMana + allyItemRedBonus * dt)
            .clamp(0.0, ally.maxRedMana);
      }
    }
  }

  /// Update wind simulation and White Mana regeneration/decay.
  ///
  /// Wind exposure drives White Mana regen. When wind drops below
  /// shelterThreshold, White Mana actively decays — unlike blue mana
  /// which simply stops regenerating.
  void updateWindAndWhiteMana(double dt) {
    _windState.update(dt);

    // Also update globalWindState for other systems (movement, projectiles)
    globalWindState = _windState;

    final config = globalWindConfig;
    final exposure = _windState.exposureLevel;
    final shelterThresh = config?.shelterThreshold ?? 0.1;

    final whiteRegenBonus = playerInventory.totalEquippedStats.whiteManaRegen;

    // Wind Affinity regen multiplier (2x when active)
    final windAffinityMult = windAffinityActive ? 2.0 : 1.0;

    // Reason: derecho storms multiply white mana regen for massive gains
    final derechoManaMult = _windState.derechoManaMultiplier;

    if (exposure >= shelterThresh) {
      // Wind is blowing — regenerate white mana (wind + item bonus)
      final regenRate = ((config?.windExposureRegen ?? 5.0) *
          exposure *
          (config?.windStrengthMultiplier ?? 1.0) +
          whiteRegenBonus) * windAffinityMult * derechoManaMult;
      currentWhiteManaRegenRate = regenRate;
      whiteMana = (whiteMana + regenRate * dt).clamp(0.0, maxWhiteMana);
    } else {
      // Sheltered — item regen still applies, but wind decay counteracts
      currentWhiteManaRegenRate = whiteRegenBonus.toDouble() * windAffinityMult;
      if (whiteRegenBonus > 0) {
        whiteMana = (whiteMana + whiteRegenBonus * windAffinityMult * dt).clamp(0.0, maxWhiteMana);
      }
      if (whiteMana > 0 && whiteRegenBonus <= 0) {
        final decay = config?.decayRate ?? 0.5;
        whiteMana = (whiteMana - decay * dt).clamp(0.0, maxWhiteMana);
      }
    }

    // ===== ALLY WHITE MANA REGEN =====
    // Allies share the global wind exposure level
    for (final ally in allies) {
      if (ally.health <= 0) continue;
      final allyWhiteRegenBonus = ally.inventory.totalEquippedStats.whiteManaRegen;

      if (exposure >= shelterThresh) {
        // Wind is blowing — ally regenerates white mana
        final allyRegenRate = (config?.windExposureRegen ?? 5.0) *
            exposure *
            (config?.windStrengthMultiplier ?? 1.0) +
            allyWhiteRegenBonus;
        ally.whiteMana = (ally.whiteMana + allyRegenRate * dt)
            .clamp(0.0, ally.maxWhiteMana);
      } else {
        // Sheltered — item regen still applies
        if (allyWhiteRegenBonus > 0) {
          ally.whiteMana = (ally.whiteMana + allyWhiteRegenBonus * dt)
              .clamp(0.0, ally.maxWhiteMana);
        }
        // Ally white mana decay when sheltered
        if (ally.whiteMana > 0 && allyWhiteRegenBonus <= 0) {
          final decay = config?.decayRate ?? 0.5;
          ally.whiteMana = (ally.whiteMana - decay * dt)
              .clamp(0.0, ally.maxWhiteMana);
        }
      }
    }

    // Flight mana drain
    if (isFlying) {
      final drainRate = config?.flightManaDrainRate ?? 3.0;
      whiteMana = (whiteMana - drainRate * dt).clamp(0.0, maxWhiteMana);

      // Low mana descent — slowly lose altitude when mana is low
      final lowThreshold = config?.lowManaThreshold ?? 33.0;
      final minAlt = config?.minAltitudeForDescent ?? 10.0;
      if (whiteMana < lowThreshold && flightAltitude >= minAlt) {
        final descentRate = config?.lowManaDescentRate ?? 2.0;
        if (playerTransform != null) {
          playerTransform!.position.y -= descentRate * dt;
        }
      }

      // Zero mana — forced landing
      if (whiteMana <= 0) {
        endFlight();
      }
    }

    // Sovereign of the Sky buff timer
    if (sovereignBuffActive) {
      sovereignBuffTimer -= dt;
      if (sovereignBuffTimer <= 0) {
        sovereignBuffActive = false;
        sovereignBuffTimer = 0.0;
        print('[FLIGHT] Sovereign of the Sky buff expired');
      }
    }

    // Wind Affinity buff timer
    if (windAffinityActive) {
      windAffinityTimer -= dt;
      if (windAffinityTimer <= 0) {
        windAffinityActive = false;
        windAffinityTimer = 0.0;
        print('[WIND] Wind Affinity buff expired');
      }
    }

    // Wind Warp speed buff timer
    if (windWarpSpeedActive) {
      windWarpSpeedTimer -= dt;
      if (windWarpSpeedTimer <= 0) {
        windWarpSpeedActive = false;
        windWarpSpeedTimer = 0.0;
        print('[WIND] Wind Warp speed buff expired');
      }
    }
  }

  // ==================== LEY LINES ====================

  /// Ley Lines manager - generates and manages magical energy lines
  LeyLineManager? leyLineManager;

  /// Initialize Ley Lines for the world
  void initializeLeyLines({int seed = 42, double worldSize = 200.0, int siteCount = 25}) {
    leyLineManager = LeyLineManager(
      seed: seed,
      worldSize: worldSize,
      siteCount: siteCount,
    );
    print('[LeyLines] Initialized with seed $seed, ${leyLineManager!.segments.length} segments');
  }

  // ==================== MONSTER STATE ====================

  Mesh? monsterMesh;
  Transform3d? monsterTransform;
  Mesh? monsterDirectionIndicator;
  Transform3d? monsterDirectionIndicatorTransform;
  double monsterRotation = 180.0; // Face toward player initially

  // Monster health and abilities
  double monsterHealth = GameConfig.monsterMaxHealth;
  final double monsterMaxHealth = GameConfig.monsterMaxHealth;
  double monsterAbility1Cooldown = 0.0;
  final double monsterAbility1CooldownMax = GameConfig.monsterAbility1CooldownMax;
  double monsterAbility2Cooldown = 0.0;
  final double monsterAbility2CooldownMax = GameConfig.monsterAbility2CooldownMax;
  double monsterAbility3Cooldown = 0.0;
  final double monsterAbility3CooldownMax = GameConfig.monsterAbility3CooldownMax;

  // Monster AI state
  bool monsterPaused = false;
  double monsterAiTimer = 0.0;
  final double monsterAiInterval = GameConfig.monsterAiInterval;
  List<Projectile> monsterProjectiles = [];

  // Monster movement and pathfinding
  BezierPath? monsterCurrentPath;
  double monsterMoveSpeed = 3.0; // Units per second
  String monsterCurrentStrategy = 'BALANCED'; // Current combat strategy

  // Monster sword state (for melee ability 1)
  Mesh? monsterSwordMesh;
  Transform3d? monsterSwordTransform;
  bool monsterAbility1Active = false;
  double monsterAbility1ActiveTime = 0.0;
  bool monsterAbility1HitRegistered = false;

  // ==================== ACTIVE CHARACTER (PARTY) ====================

  /// Index of the active party member: 0 = Warchief, 1+ = ally index + 1
  int activeCharacterIndex = 0;

  /// Whether the active character is the Warchief
  bool get isWarchiefActive => activeCharacterIndex == 0;

  /// Get the active ally (null if Warchief is active)
  Ally? get activeAlly {
    if (activeCharacterIndex == 0 || activeCharacterIndex > allies.length) {
      return null;
    }
    return allies[activeCharacterIndex - 1];
  }

  /// Cycle active character forward (] key)
  void cycleActiveCharacterNext() {
    final total = 1 + allies.length;
    activeCharacterIndex = (activeCharacterIndex + 1) % total;
    _resetPhysicsForSwitch();
  }

  /// Cycle active character backward ([ key)
  void cycleActiveCharacterPrev() {
    final total = 1 + allies.length;
    activeCharacterIndex = (activeCharacterIndex - 1 + total) % total;
    _resetPhysicsForSwitch();
  }

  /// Transform of the currently controlled character (Warchief or active ally)
  Transform3d? get activeTransform =>
      isWarchiefActive ? playerTransform : activeAlly?.transform;

  /// Rotation of the currently controlled character
  double get activeRotation =>
      isWarchiefActive ? playerRotation : (activeAlly?.rotation ?? 0.0);

  /// Set rotation of the currently controlled character
  set activeRotation(double val) {
    if (isWarchiefActive) {
      playerRotation = val;
    } else if (activeAlly != null) {
      activeAlly!.rotation = val;
    }
  }

  /// Effective speed of the currently controlled character
  double get activeEffectiveSpeed =>
      isWarchiefActive ? effectivePlayerSpeed : (activeAlly?.moveSpeed ?? 2.5);

  /// Reset physics state when switching active character
  /// Prevents carried velocity / jump state from bleeding across characters
  void _resetPhysicsForSwitch() {
    verticalVelocity = 0.0;
    isJumping = false;
    isGrounded = true;
    jumpsRemaining = maxJumps;
    cancelCast();
    cancelWindup();
    // End flight if switching away from Warchief
    if (!isWarchiefActive && isFlying) {
      endFlight();
    }
  }

  /// Selected index in the character panel carousel (null = not externally set)
  int? characterPanelSelectedIndex;

  // ==================== FRIENDLY TARGET CYCLING ====================

  /// Index for friendly tab targeting cycle
  int _friendlyTabIndex = -1;

  /// Get list of targetable friendlies (player + alive allies)
  List<String> getTargetableFriendlies() {
    final targets = <String>['player'];
    for (int i = 0; i < allies.length; i++) {
      if (allies[i].health > 0) targets.add('ally_$i');
    }
    return targets;
  }

  /// Cycle to next friendly target (Shift+Tab)
  void tabToNextFriendlyTarget() {
    final targets = getTargetableFriendlies();
    if (targets.isEmpty) return;
    _friendlyTabIndex++;
    if (_friendlyTabIndex >= targets.length) _friendlyTabIndex = 0;
    currentTargetId = targets[_friendlyTabIndex];
  }

  // ==================== ALLY STATE ====================

  List<Ally> allies = []; // Start with zero allies
  FormationType currentFormation = FormationType.scattered; // Active formation
  Map<Ally, TacticalPosition>? _cachedTacticalPositions;
  double _tacticalPositionCacheTime = 0.0;

  /// Get tactical positions for all allies (cached for performance)
  Map<Ally, TacticalPosition> getTacticalPositions() {
    // Recalculate every 0.5 seconds or when cache is invalid
    final now = DateTime.now().millisecondsSinceEpoch / 1000.0;
    if (_cachedTacticalPositions == null ||
        now - _tacticalPositionCacheTime > 0.5) {
      _cachedTacticalPositions = TacticalPositioning.calculatePositions(
        this,
        currentFormation,
      );
      _tacticalPositionCacheTime = now;
    }
    return _cachedTacticalPositions!;
  }

  /// Force recalculation of tactical positions
  void invalidateTacticalPositions() {
    _cachedTacticalPositions = null;
  }

  // ==================== MINIONS STATE ====================

  /// List of active minion instances
  List<Monster> minions = [];

  /// Whether minions have been spawned this session
  bool minionsSpawned = false;

  /// Direction indicator meshes for minions (shared by type)
  final Map<String, Mesh> _minionDirectionIndicators = {};

  /// Get or create direction indicator mesh for a minion type
  Mesh getMinionDirectionIndicator(MonsterDefinition definition) {
    return _minionDirectionIndicators.putIfAbsent(
      definition.id,
      () => Mesh.triangle(
        size: 0.3 * definition.effectiveScale,
        color: definition.accentColor,
      ),
    );
  }

  /// Spawn all minions according to DefaultMinionSpawns configuration
  /// Total: 8 Goblin Rogues + 4 Orc Warlocks + 2 Cultist Priests + 1 Skeleton Champion = 15 minions
  void spawnMinions(InfiniteTerrainManager? terrainManager) {
    if (minionsSpawned) return;

    print('[MINIONS] Spawning minions...');
    print(DefaultMinionSpawns.summary);

    // Base spawn position (offset from monster)
    final baseX = GameConfig.monsterStartPosition.x;
    final baseZ = GameConfig.monsterStartPosition.z - 10; // Behind the boss

    int totalSpawned = 0;

    for (final spawnConfig in DefaultMinionSpawns.spawns) {
      final definition = MinionDefinitions.getById(spawnConfig.definitionId);
      if (definition == null) {
        print('[MINIONS] Warning: Unknown definition ${spawnConfig.definitionId}');
        continue;
      }

      // Calculate spawn center for this group (arrange groups in a line)
      final groupOffset = totalSpawned * 0.5;
      final centerX = baseX + (groupOffset % 4) * 4 - 6;
      final centerZ = baseZ - (groupOffset ~/ 4) * 4;

      // Get terrain height at spawn center
      double centerY = 0.0;
      if (terrainManager != null) {
        centerY = terrainManager.getTerrainHeight(centerX, centerZ);
      }

      // Create monsters for this group
      final monsters = MonsterFactory.createGroup(
        definition: definition,
        centerPosition: Vector3(centerX, centerY, centerZ),
        count: spawnConfig.count,
        spreadRadius: spawnConfig.spreadRadius,
      );

      // Adjust Y positions to terrain height (add half size so bottom sits on terrain)
      for (final monster in monsters) {
        if (terrainManager != null) {
          final terrainY = terrainManager.getTerrainHeight(
            monster.transform.position.x,
            monster.transform.position.z,
          );
          // Add half the minion size + buffer so bottom of mesh sits above terrain
          const double terrainBuffer = 0.15;
          monster.transform.position.y = terrainY + definition.effectiveScale / 2 + terrainBuffer;
          // Direction indicator sits on top of the mesh
          if (monster.directionIndicatorTransform != null) {
            monster.directionIndicatorTransform!.position.y =
                monster.transform.position.y + definition.effectiveScale / 2 + 0.1;
          }
        }
      }

      minions.addAll(monsters);
      totalSpawned += spawnConfig.count;

      print('[MINIONS] Spawned ${spawnConfig.count}x ${definition.name} '
          '(MP ${definition.monsterPower})');
    }

    minionsSpawned = true;
    print('[MINIONS] Total spawned: ${minions.length} minions');
    print('[MINIONS] Total Monster Power: ${DefaultMinionSpawns.totalMonsterPower}');
  }

  /// Get all alive minions
  List<Monster> get aliveMinions => minions.where((m) => m.isAlive).toList();

  /// Get minions by archetype
  List<Monster> getMinionsByArchetype(MonsterArchetype archetype) {
    return minions.where((m) =>
        m.isAlive && m.definition.archetype == archetype).toList();
  }

  /// Get the nearest minion to a position
  Monster? getNearestMinion(Vector3 position, {double maxRange = double.infinity}) {
    Monster? nearest;
    double nearestDist = maxRange;

    for (final minion in aliveMinions) {
      final dist = minion.distanceTo(position);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = minion;
      }
    }

    return nearest;
  }

  // ==================== AI CHAT ====================

  List<AIChatMessage> monsterAIChat = [];

  // ==================== TARGETING STATE ====================

  /// Current player target ID ('boss' for main monster, or minion instanceId)
  String? currentTargetId;

  /// Target indicator mesh (yellow dashed rectangle)
  Mesh? targetIndicatorMesh;
  Transform3d? targetIndicatorTransform;
  double lastTargetIndicatorSize = 0.0; // Track size for recreation
  String? lastTargetIndicatorId; // Track target for color change detection

  /// Index for tab targeting cycle
  int _tabTargetIndex = -1;

  /// Cached list of targetable enemies for tab cycling
  List<String> _targetableEnemyIds = [];
  double _targetListCacheTime = 0.0;

  /// Get the currently targeted entity
  /// Returns a map with 'type' ('boss', 'minion', or 'dummy') and the entity itself
  Map<String, dynamic>? getCurrentTarget() {
    if (currentTargetId == null) return null;

    if (currentTargetId == 'player') {
      return {
        'type': 'player',
        'entity': null,
        'id': 'player',
      };
    }

    if (currentTargetId == 'boss') {
      return {
        'type': 'boss',
        'entity': null, // Boss is accessed directly via gameState
        'id': 'boss',
      };
    }

    // Check for target dummy
    if (currentTargetId == TargetDummy.instanceId && targetDummy != null && targetDummy!.isSpawned) {
      return {
        'type': 'dummy',
        'entity': targetDummy,
        'id': TargetDummy.instanceId,
      };
    }

    // Check for ally target
    if (currentTargetId!.startsWith('ally_')) {
      final index = int.tryParse(currentTargetId!.substring(5));
      if (index != null && index < allies.length && allies[index].health > 0) {
        return {
          'type': 'ally',
          'entity': allies[index],
          'id': currentTargetId,
        };
      }
      // Ally is dead or invalid, clear it
      currentTargetId = null;
      return null;
    }

    // Find minion by instance ID
    final minion = minions.firstWhere(
      (m) => m.instanceId == currentTargetId && m.isAlive,
      orElse: () => minions.firstWhere((m) => false, orElse: () => minions.first),
    );

    if (minion.instanceId == currentTargetId && minion.isAlive) {
      return {
        'type': 'minion',
        'entity': minion,
        'id': currentTargetId,
      };
    }

    // Target is dead or invalid, clear it
    currentTargetId = null;
    return null;
  }

  /// Get XZ-plane distance from player to current target
  /// Returns null if no target or no player position
  double? getDistanceToCurrentTarget() {
    if (currentTargetId == null || playerTransform == null) return null;

    final playerPos = playerTransform!.position;

    if (currentTargetId == 'boss') {
      if (monsterTransform != null && monsterHealth > 0) {
        final dx = monsterTransform!.position.x - playerPos.x;
        final dz = monsterTransform!.position.z - playerPos.z;
        return sqrt(dx * dx + dz * dz);
      }
      return null;
    }

    if (currentTargetId == TargetDummy.instanceId && targetDummy != null && targetDummy!.isSpawned) {
      return targetDummy!.distanceToXZ(playerPos);
    }

    // Check allies
    if (currentTargetId!.startsWith('ally_')) {
      final index = int.tryParse(currentTargetId!.substring(5));
      if (index != null && index < allies.length && allies[index].health > 0) {
        final dx = allies[index].transform.position.x - playerPos.x;
        final dz = allies[index].transform.position.z - playerPos.z;
        return sqrt(dx * dx + dz * dz);
      }
      return null;
    }

    // Check minions
    for (final minion in aliveMinions) {
      if (minion.instanceId == currentTargetId) {
        final dx = minion.transform.position.x - playerPos.x;
        final dz = minion.transform.position.z - playerPos.z;
        return sqrt(dx * dx + dz * dz);
      }
    }

    return null;
  }

  /// Get target's current target (target of target)
  String? getTargetOfTarget() {
    final target = getCurrentTarget();
    if (target == null) return null;

    if (target['type'] == 'boss') {
      // Boss always targets player (for now)
      return 'player';
    } else if (target['type'] == 'minion') {
      final minion = target['entity'] as Monster;
      return minion.targetId ?? 'none';
    } else if (target['type'] == 'ally') {
      // Allies always "target" player for simplicity
      return 'player';
    } else if (target['type'] == 'dummy') {
      // Dummy doesn't target anyone
      return 'none';
    }

    return null;
  }

  /// Set the current target by ID
  void setTarget(String? targetId) {
    currentTargetId = targetId;
    // Update tab index to match
    if (targetId != null) {
      final index = _targetableEnemyIds.indexOf(targetId);
      if (index >= 0) {
        _tabTargetIndex = index;
      }
    }
  }

  /// Clear current target
  void clearTarget() {
    currentTargetId = null;
    _tabTargetIndex = -1;
  }

  /// Get ordered list of targetable enemies (for tab targeting)
  /// Sorted by angle from player's facing direction, then by distance
  List<String> getTargetableEnemies(double playerX, double playerZ, double playerRotation) {
    final now = DateTime.now().millisecondsSinceEpoch / 1000.0;

    // Cache for 0.2 seconds
    if (_targetableEnemyIds.isNotEmpty && now - _targetListCacheTime < 0.2) {
      return _targetableEnemyIds;
    }

    final targets = <_TargetCandidate>[];
    final playerFacingRad = playerRotation * 3.14159 / 180.0;
    final playerFacingX = -sin(playerFacingRad);
    final playerFacingZ = -cos(playerFacingRad);

    // Add target dummy if spawned (prioritize for DPS testing)
    if (targetDummy != null && targetDummy!.isSpawned) {
      final dx = targetDummy!.position.x - playerX;
      final dz = targetDummy!.position.z - playerZ;
      final dist = sqrt(dx * dx + dz * dz);
      final angle = _calculateAngleToTarget(dx, dz, playerFacingX, playerFacingZ, dist);
      targets.add(_TargetCandidate(TargetDummy.instanceId, dist, angle));
    }

    // Add boss if alive
    if (monsterHealth > 0 && monsterTransform != null) {
      final dx = monsterTransform!.position.x - playerX;
      final dz = monsterTransform!.position.z - playerZ;
      final dist = sqrt(dx * dx + dz * dz);
      final angle = _calculateAngleToTarget(dx, dz, playerFacingX, playerFacingZ, dist);
      targets.add(_TargetCandidate('boss', dist, angle));
    }

    // Add alive minions
    for (final minion in aliveMinions) {
      final dx = minion.transform.position.x - playerX;
      final dz = minion.transform.position.z - playerZ;
      final dist = sqrt(dx * dx + dz * dz);
      final angle = _calculateAngleToTarget(dx, dz, playerFacingX, playerFacingZ, dist);
      targets.add(_TargetCandidate(minion.instanceId, dist, angle));
    }

    // Sort: prioritize enemies in front (small angle), then by distance
    // Cone preference: enemies within 60 degrees of facing direction get priority
    targets.sort((a, b) {
      final aInCone = a.angle < 60;
      final bInCone = b.angle < 60;

      if (aInCone && !bInCone) return -1;
      if (!aInCone && bInCone) return 1;

      // Within same cone status, sort by angle first, then distance
      if (aInCone && bInCone) {
        final angleDiff = a.angle - b.angle;
        if (angleDiff.abs() > 10) return angleDiff.toInt();
      }

      return (a.distance - b.distance).sign.toInt();
    });

    _targetableEnemyIds = targets.map((t) => t.id).toList();
    _targetListCacheTime = now;

    return _targetableEnemyIds;
  }

  /// Calculate angle (in degrees) between player facing and target direction
  double _calculateAngleToTarget(double dx, double dz, double facingX, double facingZ, double dist) {
    if (dist < 0.001) return 0;
    final targetDirX = dx / dist;
    final targetDirZ = dz / dist;
    final dot = facingX * targetDirX + facingZ * targetDirZ;
    final clampedDot = dot.clamp(-1.0, 1.0);
    return acos(clampedDot) * 180.0 / 3.14159;
  }

  /// Tab to next target (WoW-style)
  void tabToNextTarget(double playerX, double playerZ, double playerRotation, {bool reverse = false}) {
    final targets = getTargetableEnemies(playerX, playerZ, playerRotation);
    if (targets.isEmpty) {
      clearTarget();
      return;
    }

    if (reverse) {
      _tabTargetIndex--;
      if (_tabTargetIndex < 0) _tabTargetIndex = targets.length - 1;
    } else {
      _tabTargetIndex++;
      if (_tabTargetIndex >= targets.length) _tabTargetIndex = 0;
    }

    currentTargetId = targets[_tabTargetIndex];
  }

  /// Check if a specific entity is the current target
  bool isTargeted(String id) => currentTargetId == id;

  /// Validate current target (clear if dead)
  void validateTarget() {
    if (currentTargetId == null) return;

    if (currentTargetId == 'player') {
      // Player is always a valid target
      return;
    }

    if (currentTargetId == 'boss') {
      if (monsterHealth <= 0) clearTarget();
    } else if (currentTargetId == TargetDummy.instanceId) {
      // Target dummy is valid as long as it's spawned
      if (targetDummy == null || !targetDummy!.isSpawned) clearTarget();
    } else if (currentTargetId!.startsWith('ally_')) {
      final index = int.tryParse(currentTargetId!.substring(5));
      if (index == null || index >= allies.length || allies[index].health <= 0) {
        clearTarget();
      }
    } else {
      final minion = minions.where((m) => m.instanceId == currentTargetId).firstOrNull;
      if (minion == null || !minion.isAlive) clearTarget();
    }
  }

  // Math helpers for targeting
  static double sqrt(double x) => x <= 0 ? 0 : _sqrtNewton(x);
  static double _sqrtNewton(double x) {
    double guess = x / 2;
    for (int i = 0; i < 10; i++) {
      guess = (guess + x / guess) / 2;
    }
    return guess;
  }
  static double sin(double x) {
    while (x > 3.14159) x -= 2 * 3.14159;
    while (x < -3.14159) x += 2 * 3.14159;
    final x2 = x * x;
    return x - x * x2 / 6 + x * x2 * x2 / 120;
  }
  static double cos(double x) {
    while (x > 3.14159) x -= 2 * 3.14159;
    while (x < -3.14159) x += 2 * 3.14159;
    final x2 = x * x;
    return 1 - x2 / 2 + x2 * x2 / 24;
  }
  static double acos(double x) {
    // Simple approximation for acos
    if (x >= 1) return 0;
    if (x <= -1) return 3.14159;
    return 3.14159 / 2 - _asinApprox(x);
  }
  static double _asinApprox(double x) {
    // Approximation: asin(x) ≈ x + x³/6 + 3x⁵/40
    final x3 = x * x * x;
    final x5 = x3 * x * x;
    return x + x3 / 6 + 3 * x5 / 40;
  }

  // ==================== MINIMAP STATE ====================

  /// Minimap state: zoom, pings, elapsed time, terrain cache
  final MinimapState minimapState = MinimapState();

  /// Whether the minimap is currently visible (M key toggle)
  bool minimapOpen = true;

  // ==================== BUILDINGS ====================

  /// Active buildings in the world.
  List<Building> buildings = [];

  /// Whether the building panel is currently open.
  bool buildingPanelOpen = false;

  /// Currently selected building (for interaction panel).
  Building? selectedBuilding;

  /// Spawn the warchief's home at a fixed position near player start.
  ///
  /// Only spawns once — skips if a warchief_home already exists.
  void spawnWarchiefHome(InfiniteTerrainManager? terrainManager) {
    if (buildings.any((b) => b.definition.id == 'warchief_home')) return;

    final config = globalBuildingConfig;
    final typeDef = BuildingDefinition.fromConfig(
      'warchief_home',
      config?.getBuildingType('warchief_home'),
    );
    if (typeDef == null) {
      print('[BUILDING] Warning: warchief_home definition not found in config');
      return;
    }

    // Place near player start, offset to the side
    final homeX = GameConfig.playerStartPosition.x + 15;
    final homeZ = GameConfig.playerStartPosition.z + 15;

    final building = _placeBuildingInternal(
      definition: typeDef,
      worldX: homeX,
      worldZ: homeZ,
      terrainManager: terrainManager,
    );

    buildings.add(building);
    print('[BUILDING] Warchief Home placed at ($homeX, $homeZ)');
  }

  /// Internal helper: place a building and return it.
  Building _placeBuildingInternal({
    required BuildingDefinition definition,
    required double worldX,
    required double worldZ,
    required InfiniteTerrainManager? terrainManager,
    int tier = 0,
  }) {
    // Imported inline to avoid circular dependency
    // Uses BuildingSystem.placeBuilding from systems layer
    final tierDef = definition.getTier(tier);
    final mesh = _createBuildingMeshFromTier(tierDef);
    double y = 0.0;
    if (terrainManager != null) {
      y = terrainManager.getTerrainHeight(worldX, worldZ);
    }
    final transform = Transform3d(
      position: Vector3(worldX, y, worldZ),
    );
    return Building(
      instanceId: '${definition.id}_${buildings.length}',
      definition: definition,
      currentTier: tier,
      mesh: mesh,
      transform: transform,
    );
  }

  /// Create building mesh from tier (delegates to BuildingMesh factory).
  static Mesh _createBuildingMeshFromTier(BuildingTierDef tier) {
    // Reason: import is at file level, keeping this as a static method
    // avoids importing building_system.dart into game_state.dart (circular)
    return _BuildingMeshHelper.create(tier);
  }

  /// Get the nearest building to player within a given range.
  ///
  /// Returns null if no building is within range.
  Building? getNearestBuilding(double range) {
    if (playerTransform == null) return null;
    final px = playerTransform!.position.x;
    final pz = playerTransform!.position.z;

    Building? nearest;
    double nearestDist = range;

    for (final building in buildings) {
      if (!building.isPlaced) continue;
      final dist = building.distanceTo(px, pz);
      if (dist < nearestDist) {
        nearestDist = dist;
        nearest = building;
      }
    }
    return nearest;
  }

  // ==================== GOALS ====================

  /// All goals (active, completed, abandoned).
  List<Goal> goals = [];

  /// Convenience: only active goals.
  List<Goal> get activeGoals =>
      goals.where((g) => g.status == GoalStatus.active).toList();

  /// Convenience: completed goals awaiting reflection.
  List<Goal> get completedGoals =>
      goals.where((g) => g.status == GoalStatus.completed).toList();

  /// Warrior Spirit chat messages.
  List<AIChatMessage> warriorSpiritMessages = [];

  /// Goal the Warrior Spirit is currently suggesting (accept/decline).
  GoalDefinition? pendingSpiritGoal;

  /// Whether the goals panel is open (G key).
  bool goalsPanelOpen = false;

  /// Whether the Warrior Spirit panel is open (V key).
  bool warriorSpiritPanelOpen = false;

  /// Melee hit streak tracker (for mastery goals).
  int consecutiveMeleeHits = 0;

  /// Visited power node IDs (for exploration goals).
  Set<String> visitedPowerNodes = {};

  // ==================== UI STATE ====================

  /// Whether the abilities modal is currently open
  bool abilitiesModalOpen = false;

  /// Whether the character panel is currently open
  bool characterPanelOpen = false;

  /// Whether the bag/inventory panel is currently open
  bool bagPanelOpen = false;

  /// Whether the DPS testing panel is currently open
  bool dpsPanelOpen = false;

  /// Whether the unified ally commands panel is currently open (F key)
  bool allyCommandPanelOpen = false;

  // ==================== DPS TESTING STATE ====================

  /// DPS tracker for measuring damage output
  final DpsTracker dpsTracker = DpsTracker();

  /// Target dummy for DPS testing (null when not spawned)
  TargetDummy? targetDummy;

  /// Spawn a target dummy 40 yards in front of the player
  void spawnTargetDummy(InfiniteTerrainManager? terrainManager) {
    if (targetDummy != null && targetDummy!.isSpawned) return;
    if (playerTransform == null) return;

    // Calculate position 40 yards (units) in front of the player
    final playerPos = playerTransform!.position;
    final playerRot = playerRotation * 3.14159 / 180.0;

    // Direction player is facing
    final dirX = -sin(playerRot);
    final dirZ = -cos(playerRot);

    // Position 40 units ahead
    const distance = 40.0;
    final dummyX = playerPos.x + dirX * distance;
    final dummyZ = playerPos.z + dirZ * distance;

    // Get terrain height at dummy position
    double dummyY = playerPos.y;
    if (terrainManager != null) {
      final terrainHeight = terrainManager.getTerrainHeight(dummyX, dummyZ);
      dummyY = terrainHeight + TargetDummy.size / 2 + 0.15;
    }

    targetDummy = TargetDummy.spawn(Vector3(dummyX, dummyY, dummyZ));

    // Start DPS tracking session
    dpsTracker.startSession();

    print('[DPS] Target Dummy spawned at ($dummyX, $dummyY, $dummyZ)');
  }

  /// Despawn the target dummy
  void despawnTargetDummy() {
    if (targetDummy == null) return;

    targetDummy!.isSpawned = false;
    targetDummy = null;

    // End DPS tracking session
    dpsTracker.endSession();

    print('[DPS] Target Dummy despawned');
  }

  /// Check if target dummy is the current target
  bool get isTargetingDummy => currentTargetId == TargetDummy.instanceId;

  // ==================== INVENTORY STATE ====================

  /// Player inventory (equipment and bag)
  final Inventory playerInventory = Inventory();

  /// Whether the inventory has been initialized with items
  bool inventoryInitialized = false;

  /// Initialize player inventory with sample items from database
  Future<void> initializeInventory() async {
    if (inventoryInitialized) return;

    // Load the item database
    await ItemDatabase.instance.load();

    // Add sample items to bag
    final sampleItems = [
      'health_potion',
      'health_potion',
      'mana_potion',
      'iron_sword',
      'chainmail_armor',
      'iron_helm',
      'leather_boots',
      'leather_gloves',
      'iron_greaves',
      'travelers_cloak',
      'wooden_shield',
      'ring_of_strength',
      'amulet_of_fortitude',
      'iron_ore',
      'gold_coin',
      'dragon_scale',
    ];

    for (final itemId in sampleItems) {
      final item = ItemDatabase.instance.createItem(itemId);
      if (item != null) {
        playerInventory.addToBag(item);
      }
    }

    // Pre-equip some items on the player
    final startingEquipment = [
      'steel_plate',
      'steel_helm',
      'war_axe',
      'tower_shield',
      'boots_of_swiftness',
      'gauntlets_of_might',
      'legplates_of_valor',
      'cloak_of_shadows',
      'signet_of_the_warchief',
      'band_of_protection',
    ];

    for (final itemId in startingEquipment) {
      final item = ItemDatabase.instance.createItem(itemId);
      if (item != null && item.isEquippable) {
        playerInventory.equip(item);
      }
    }

    // Set player health to full after equipping starting gear
    playerHealth = playerMaxHealth;

    inventoryInitialized = true;
    print('[GameState] Inventory initialized with ${playerInventory.usedBagSlots} bag items and equipment');
    print('[GameState] Player max health: $playerMaxHealth (base $basePlayerMaxHealth + ${playerInventory.totalEquippedStats.health} from gear)');
  }

  // ==================== FLIGHT STATE ====================

  /// Whether the player is currently flying
  bool isFlying = false;

  /// Current pitch angle in degrees (-45 to +45). Positive = climb, negative = dive.
  double flightPitchAngle = 0.0;

  /// Current flight speed (modified by ALT boost / Space brake)
  double flightSpeed = 7.0;

  /// Current bank angle in degrees. Positive = right, negative = left.
  double flightBankAngle = 0.0;

  /// Current height above terrain (computed each frame by physics system)
  double flightAltitude = 0.0;

  /// Whether the Sovereign of the Sky buff is active
  bool sovereignBuffActive = false;

  /// Remaining time on Sovereign buff
  double sovereignBuffTimer = 0.0;

  /// Whether the Wind Affinity buff is active (doubles white mana regen)
  bool windAffinityActive = false;

  /// Remaining time on Wind Affinity buff
  double windAffinityTimer = 0.0;

  /// Whether Silent Mind is active (next white ability is free + instant)
  bool silentMindActive = false;

  /// Whether Wind Warp flight speed buff is active (doubles flight speed)
  bool windWarpSpeedActive = false;

  /// Remaining time on Wind Warp speed buff
  double windWarpSpeedTimer = 0.0;

  /// Start flight if player has enough White Mana for initial cost.
  ///
  /// Spends the initial mana cost and sets isFlying = true.
  void startFlight() {
    final config = globalWindConfig;
    final cost = config?.initialManaCost ?? 15.0;
    if (!hasWhiteMana(cost)) {
      print('[FLIGHT] Not enough White Mana to take flight (need $cost)');
      return;
    }
    spendWhiteMana(cost);
    isFlying = true;
    flightPitchAngle = 0.0;
    flightBankAngle = 0.0;
    flightSpeed = config?.flightSpeed ?? 7.0;
    // Reset visual roll
    if (playerTransform != null) {
      playerTransform!.rotation.z = 0.0;
    }
    // Cancel any cast/windup when entering flight
    cancelCast();
    cancelWindup();
    print('[FLIGHT] Taking flight! (spent ${cost.toStringAsFixed(0)} White Mana)');
  }

  /// End flight — reset all flight state.
  void endFlight() {
    isFlying = false;
    flightPitchAngle = 0.0;
    flightBankAngle = 0.0;
    flightSpeed = globalWindConfig?.flightSpeed ?? 7.0;
    // Reset visual roll
    if (playerTransform != null) {
      playerTransform!.rotation.z = 0.0;
    }
    print('[FLIGHT] Flight ended');
  }

  /// Toggle flight on/off.
  void toggleFlight() {
    if (isFlying) {
      endFlight();
    } else {
      startFlight();
    }
  }

  // ==================== JUMP/PHYSICS STATE ====================

  bool isJumping = false;
  double verticalVelocity = 0.0;
  bool isGrounded = true;
  int jumpsRemaining = 2; // Allow 2 jumps total (ground jump + air jump)
  final int maxJumps = 2;
  final double jumpForce = GameConfig.jumpVelocity;
  final double gravity = GameConfig.gravity;
  final double groundLevel = GameConfig.groundLevel;
  bool jumpKeyWasPressed = false; // Track previous jump key state

  // ==================== CASTING/WINDUP STATE ====================

  /// Whether the player is currently casting a spell with cast time
  bool isCasting = false;

  /// Current cast progress in seconds (0 to castTime)
  double castProgress = 0.0;

  /// The total cast time of the current spell being cast
  double currentCastTime = 0.0;

  /// The slot index of the ability being cast
  int? castingSlotIndex;

  /// Name of the ability being cast (for UI display)
  String castingAbilityName = '';

  /// Whether the player is currently winding up a melee attack
  bool isWindingUp = false;

  /// Current windup progress in seconds (0 to windupTime)
  double windupProgress = 0.0;

  /// The total windup time of the current melee attack
  double currentWindupTime = 0.0;

  /// The slot index of the ability being wound up
  int? windupSlotIndex;

  /// Name of the ability being wound up (for UI display)
  String windupAbilityName = '';

  /// Movement speed modifier from windup (0.0 = stopped, 1.0 = full speed)
  double windupMovementSpeedModifier = 1.0;

  /// Pending mana cost to spend when cast/windup completes.
  /// If interrupted, cost is not spent.
  double pendingManaCost = 0.0;

  /// Whether the pending mana is blue (true) or red (false)
  /// Note: for white mana, use pendingManaType = 2
  bool pendingManaIsBlue = true;

  /// Pending mana type: 0=blue, 1=red, 2=white
  int pendingManaType = 0;

  /// Get the effective movement speed considering windup modifier
  double get effectivePlayerSpeed => playerSpeed * windupMovementSpeedModifier;

  /// Cancel any active cast (called when player moves during stationary cast)
  void cancelCast() {
    if (isCasting) {
      print('[CAST] $castingAbilityName cast cancelled — mana and cooldown preserved');
      isCasting = false;
      castProgress = 0.0;
      currentCastTime = 0.0;
      castingSlotIndex = null;
      castingAbilityName = '';
      pendingManaCost = 0.0;
    }
  }

  /// Cancel any active windup
  void cancelWindup() {
    if (isWindingUp) {
      print('[WINDUP] $windupAbilityName windup cancelled — mana and cooldown preserved');
      isWindingUp = false;
      windupProgress = 0.0;
      currentWindupTime = 0.0;
      windupSlotIndex = null;
      windupAbilityName = '';
      windupMovementSpeedModifier = 1.0;
      pendingManaCost = 0.0;
    }
  }

  /// Check if player is performing any cast/windup action
  bool get isPerformingAction => isCasting || isWindingUp;

  /// Get cast progress as percentage (0.0 to 1.0)
  double get castPercentage => currentCastTime > 0 ? castProgress / currentCastTime : 0.0;

  /// Get windup progress as percentage (0.0 to 1.0)
  double get windupPercentage => currentWindupTime > 0 ? windupProgress / currentWindupTime : 0.0;

  // ==================== ABILITY 1: SWORD ====================

  double ability1Cooldown = 0.0;
  final double ability1CooldownMax = GameConfig.ability1CooldownMax;
  bool ability1Active = false;
  double ability1ActiveTime = 0.0;
  final double ability1Duration = GameConfig.ability1Duration;
  bool ability1HitRegistered = false; // Prevent multiple hits per swing
  Mesh? swordMesh;
  Transform3d? swordTransform;

  // ==================== ABILITY 2: FIREBALL ====================

  double ability2Cooldown = 0.0;
  final double ability2CooldownMax = GameConfig.ability2CooldownMax;
  List<Projectile> fireballs = []; // List of active fireballs

  // ==================== ABILITY 3: HEAL ====================

  double ability3Cooldown = 0.0;
  final double ability3CooldownMax = GameConfig.ability3CooldownMax;
  bool ability3Active = false;
  double ability3ActiveTime = 0.0;
  final double ability3Duration = 1.0; // Heal effect duration
  Mesh? healEffectMesh;
  Transform3d? healEffectTransform;

  // ==================== ABILITY 4: DASH ATTACK ====================

  double ability4Cooldown = 0.0;
  final double ability4CooldownMax = 6.0; // 6 second cooldown
  bool ability4Active = false;
  double ability4ActiveTime = 0.0;
  final double ability4Duration = 0.4; // Dash duration
  bool ability4HitRegistered = false; // Prevent multiple hits per dash
  Mesh? dashTrailMesh;
  Transform3d? dashTrailTransform;

  // ==================== ABILITIES 5-10 (Extended Action Bar) ====================

  double ability5Cooldown = 0.0;
  final double ability5CooldownMax = 5.0;

  double ability6Cooldown = 0.0;
  final double ability6CooldownMax = 5.0;

  double ability7Cooldown = 0.0;
  final double ability7CooldownMax = 5.0;

  double ability8Cooldown = 0.0;
  final double ability8CooldownMax = 5.0;

  double ability9Cooldown = 0.0;
  final double ability9CooldownMax = 5.0;

  double ability10Cooldown = 0.0;
  final double ability10CooldownMax = 5.0;

  // ==================== VISUAL EFFECTS ====================

  List<ImpactEffect> impactEffects = []; // List of active impact effects
  List<DamageIndicator> damageIndicators = []; // Floating damage numbers

  // ==================== MOVEMENT TRACKING ====================

  /// Player movement tracker for AI prediction
  final PlayerMovementTracker playerMovementTracker = PlayerMovementTracker();

  // ==================== GAME LOOP STATE ====================

  int? animationFrameId;
  /// Last requestAnimationFrame timestamp in milliseconds (from performance.now()).
  /// Using the rAF timestamp instead of DateTime.now() gives monotonic,
  /// sub-millisecond precision that is synchronized with display refresh,
  /// preventing timing drift in cast bars and windups.
  double? lastTimestamp;
  int frameCount = 0;
}

/// Helper class for sorting target candidates
class _TargetCandidate {
  final String id;
  final double distance;
  final double angle; // Angle from player's facing direction

  _TargetCandidate(this.id, this.distance, this.angle);
}

/// Helper to create building meshes without importing building_system.dart.
///
/// Reason: game_state.dart must not import building_system.dart because
/// building_system.dart imports game_state.dart. This helper delegates
/// to BuildingMesh directly instead.
class _BuildingMeshHelper {
  static Mesh create(BuildingTierDef tier) {
    // Inline import to avoid circular dependency
    return _createFromParts(tier);
  }

  /// Minimal mesh creation from tier parts.
  /// Delegates to the BuildingMesh factory via the rendering3d layer.
  static Mesh _createFromParts(BuildingTierDef tier) {
    // Use the same factory as building_mesh.dart
    // This import is safe because rendering3d has no dependency on game3d/state
    return BuildingMesh.createBuilding(tier);
  }
}
