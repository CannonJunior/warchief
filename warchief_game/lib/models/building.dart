import 'dart:math' as math;
import '../rendering3d/mesh.dart';
import '../rendering3d/math/transform3d.dart';

/// Building tier definition loaded from config JSON.
///
/// Each tier represents a visual and stat upgrade for a building type.
/// Parts define the geometry dimensions and colors for mesh generation.
class BuildingTierDef {
  final int tier;
  final String name;
  final Map<String, dynamic> parts;
  final double auraRadius;
  final double healthRegen;
  final double manaRegen;
  final List<double> minimapColor;
  final double minimapSize;

  BuildingTierDef({
    required this.tier,
    required this.name,
    required this.parts,
    required this.auraRadius,
    required this.healthRegen,
    required this.manaRegen,
    required this.minimapColor,
    required this.minimapSize,
  });

  /// Parse a BuildingTierDef from a JSON tier entry.
  factory BuildingTierDef.fromJson(Map<String, dynamic> json) {
    final aura = json['aura'] as Map<String, dynamic>? ?? {};
    final colorList = json['minimap_color'];

    return BuildingTierDef(
      tier: (json['tier'] as num?)?.toInt() ?? 1,
      name: json['name'] as String? ?? 'Unknown',
      parts: Map<String, dynamic>.from(json['parts'] as Map? ?? {}),
      auraRadius: (aura['radius'] as num?)?.toDouble() ?? 10.0,
      healthRegen: (aura['health_regen'] as num?)?.toDouble() ?? 0.0,
      manaRegen: (aura['mana_regen'] as num?)?.toDouble() ?? 0.0,
      minimapColor: colorList is List
          ? colorList.map((e) => (e as num).toDouble()).toList()
          : [0.7, 0.5, 0.2, 1.0],
      minimapSize: (json['minimap_size'] as num?)?.toDouble() ?? 5.0,
    );
  }

  /// Get a part definition by name (foundation, walls, roof, door).
  Map<String, dynamic>? getPart(String partName) {
    final part = parts[partName];
    if (part is Map<String, dynamic>) return part;
    return null;
  }
}

/// Building type definition describing a category of building.
///
/// Contains the ID, display name, description, category, and all tier
/// definitions. Buildings are created from definitions.
class BuildingDefinition {
  final String id;
  final String name;
  final String description;
  final String category;
  final List<BuildingTierDef> tiers;

  BuildingDefinition({
    required this.id,
    required this.name,
    required this.description,
    required this.category,
    required this.tiers,
  });

  /// Get the tier definition for a specific tier, clamped to valid range.
  BuildingTierDef getTier(int tier) {
    if (tiers.isEmpty) {
      return BuildingTierDef(
        tier: 1,
        name: 'Default',
        parts: {},
        auraRadius: 10.0,
        healthRegen: 0.0,
        manaRegen: 0.0,
        minimapColor: [0.7, 0.5, 0.2, 1.0],
        minimapSize: 5.0,
      );
    }
    final index = tier.clamp(0, tiers.length - 1);
    return tiers[index];
  }

  /// Parse a BuildingDefinition from config JSON.
  ///
  /// Returns null if the JSON is null or invalid.
  static BuildingDefinition? fromConfig(
      String id, Map<String, dynamic>? json) {
    if (json == null) return null;

    final tiersList = json['tiers'] as List<dynamic>? ?? [];
    final tiers = tiersList
        .map((t) =>
            BuildingTierDef.fromJson(Map<String, dynamic>.from(t as Map)))
        .toList();

    return BuildingDefinition(
      id: id,
      name: json['name'] as String? ?? 'Unknown Building',
      description: json['description'] as String? ?? '',
      category: json['category'] as String? ?? 'general',
      tiers: tiers,
    );
  }
}

/// Runtime building instance placed in the game world.
///
/// Follows the same Mesh + Transform3d pattern as Monster, Ally,
/// and TargetDummy. Buildings are static structures with aura effects.
class Building {
  final String instanceId;
  final BuildingDefinition definition;
  int currentTier;

  /// Visual representation (generated by BuildingMesh factory).
  Mesh mesh;
  Transform3d transform;

  /// Whether this building has been placed in the world.
  bool isPlaced;

  /// Construction progress (0.0 to 1.0). Reserved for future build-over-time.
  double constructionProgress;

  Building({
    required this.instanceId,
    required this.definition,
    required this.currentTier,
    required this.mesh,
    required this.transform,
    this.isPlaced = true,
    this.constructionProgress = 1.0,
  });

  /// Current tier definition (shorthand).
  BuildingTierDef get tierDef => definition.getTier(currentTier);

  /// Aura radius for the current tier.
  double get auraRadius => tierDef.auraRadius;

  /// Health regen per second within the aura.
  double get healthRegen => tierDef.healthRegen;

  /// Mana regen per second within the aura.
  double get manaRegen => tierDef.manaRegen;

  /// Check if a world position is within this building's aura.
  bool isInAura(double worldX, double worldZ) {
    final dx = transform.position.x - worldX;
    final dz = transform.position.z - worldZ;
    return (dx * dx + dz * dz) <= (auraRadius * auraRadius);
  }

  /// Check if a world position is within interaction range.
  bool isInRange(double worldX, double worldZ, double range) {
    final dx = transform.position.x - worldX;
    final dz = transform.position.z - worldZ;
    return (dx * dx + dz * dz) <= (range * range);
  }

  /// Get XZ distance to a world position.
  double distanceTo(double worldX, double worldZ) {
    final dx = transform.position.x - worldX;
    final dz = transform.position.z - worldZ;
    return math.sqrt(dx * dx + dz * dz);
  }

  /// Whether this building can be upgraded to a higher tier.
  bool get canUpgrade => currentTier < definition.tiers.length - 1;
}
